Sure, here is the translated Fortran code in C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nbool has_close_elements(const std::vector<float>& numbers, int n, float threshold) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<float> a;\n    int n;\n    \n    // Test case 1\n    a = { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 };\n    n = a.size();\n    if (!has_close_elements(a, n, 0.3)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    if (has_close_elements(a, n, 0.05)) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    \n    // Test case 2\n    a = { 1.0, 2.0, 5.9, 4.0, 5.0 };\n    n = a.size();\n    if (!has_close_elements(a, n, 0.95)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    if (has_close_elements(a, n, 0.8)) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    \n    // Test case 3\n    a = { 1.0, 2.0, 3.0, 4.0, 5.0 };\n    n = a.size();\n    if (!has_close_elements(a, n, 2.0)) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    \n    // Test case 4\n    a = { 1.1, 2.2, 3.1, 4.1, 5.1 };\n    n = a.size();\n    if (!has_close_elements(a, n, 1.0)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n    if (has_close_elements(a, n, 0.5)) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code translates the provided Fortran code to C++. It uses the `std::vector<float>` to handle arrays of floating-point numbers and the standard C++ library to handle input/output and mathematical functions. The logic remains the same, ensuring that the functionality is preserved.
Here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nbool below_zero(const std::vector<int>& operations) {\n    int num = 0;\n    for (int op : operations) {\n        num += op;\n        if (num < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> operations;\n    bool result;\n\n    // Test case 1\n    operations = {};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    operations = {1, 2, -3, 1, 2, -3};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    operations = {1, 2, -4, 5, 6};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    operations = {1, -1, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != false) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    operations = {1, -1, 2, -2, 5, -5, 4, -5};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    operations = {1, -2, 2, -2, 5, -5, 4, -4};\n    result = below_zero(operations);\n    if (result != true) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n1. **Header Inclusions**: `#include <iostream>` for standard I/O operations and `#include <vector>` for dynamic arrays.\n2. **`below_zero` Function**: This function takes a `std::vector<int>` as an argument, sums its elements and returns `true` if the running sum goes below zero, otherwise `false`.\n3. **Main Function**:\n    - Test cases with dynamic arrays (`std::vector<int> operations`).\n    - Each test case initializes `operations` with specific values, calls the `below_zero` function, and checks the returned result.\n    - If a test case fails, a message is printed and the program exits with a non-zero status.\n4. **Prints result**: If all tests pass, a success message is printed.
Sure, here's the Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n\n// Function to compute the Mean Absolute Deviation\ndouble mean_absolute_deviation(const std::vector<double>& numbers) {\n    double sum = 0.0;\n    for(double num : numbers) {\n        sum += num;\n    }\n    double avg = sum / numbers.size();\n\n    double msum = 0.0;\n    for(double num : numbers) {\n        msum += std::abs(num - avg);\n    }\n    return msum / numbers.size();\n}\n\nint main() {\n    double result;\n\n    // Test cases\n    result = mean_absolute_deviation({1.0, 2.0, 3.0});\n    assert(std::abs(result - 2.0/3.0) < 1e-4 && "Assertion failed for test case 1");\n\n    result = mean_absolute_deviation({1.0, 2.0, 3.0, 4.0});\n    assert(std::abs(result - 1.0) < 1e-4 && "Assertion failed for test case 2");\n\n    result = mean_absolute_deviation({1.0, 2.0, 3.0, 4.0, 5.0});\n    assert(std::abs(result - 6.0/5.0) < 1e-4 && "Assertion failed for test case 3");\n\n    std::cout << "All test cases passed\n";\n\n    return 0;\n}\n```\n### Explanation:\n1. **Function Definition**:\n   - The `mean_absolute_deviation` function takes a `std::vector<double>` as input and returns a `double`.\n   - The function calculates the mean of the input numbers.\n   - It then calculates the mean absolute deviation by summing the absolute differences between each number and the mean.\n\n2. **Test Cases**:\n   - A simple `main` function is provided which runs the `mean_absolute_deviation` function on three different test cases.\n   - The `assert` function is used to check if the result matches the expected value within a tolerance of `1e-4`. If any assertion fails, an error message specific to the test case is shown. \n\n3. **Output**:\n   - The program prints "All test cases passed" if all assertions are successful.\n\nThis C++ program captures the core functionality and logic of the original Fortran code in an idiomatic C++ style.
Translating the given Fortran code to C++ involves several steps. Below is a C++ program that preserves the logic and structure of the Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid intersperse(const std::vector<int>& numbers, int delimiter, std::vector<int>& out) {\n    int n = numbers.size();\n    if (n == 0) {\n        out.clear();\n    } else {\n        out.resize(2 * n - 1);\n        out[0] = numbers[0];\n        for (int i = 1; i < n; ++i) {\n            out[2 * i - 1] = delimiter;\n            out[2 * i] = numbers[i];\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n    int delimiter;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    intersperse(numbers, 7, result);\n    assert(issame(result, expected));\n\n    // Test case 2\n    numbers = { 5, 6, 3, 2 };\n    expected = { 5, 8, 6, 8, 3, 8, 2 };\n    intersperse(numbers, 8, result);\n    assert(issame(result, expected));\n\n    // Test case 3\n    numbers = { 2, 2, 2 };\n    expected = { 2, 2, 2, 2, 2 };\n    intersperse(numbers, 2, result);\n    assert(issame(result, expected));\n\n    std::cout << "All tests passed successfully!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Utility Functions:**\n   - `intersperse`: This function accepts a vector of numbers, a delimiter, and an output vector. It processes the input vector to insert the delimiter between elements and stores the result in the output vector.\n   - `issame`: This function compares two vectors to check if they are identical in size and content.\n\n2. **Main Function:**\n   - The main function defines several test cases similar to the original Fortran code.\n   - It uses the `intersperse` function to process each test case and `assert` to verify the results against the expected output.\n   - If any assertion fails, the program will terminate with an error message. If all assertions pass, it prints a success message.\n\nThis implementation captures the same functionality and test cases as described in the Fortran code using `std::vector` for dynamic arrays and C++ `assert` for test validation.
Sure! Here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nvoid parse_nested_parens(const std::string& paren_string, std::vector<int>& all_levels) {\n    int level = 0;\n    int max_level = 0;\n    int n = paren_string.size();\n    std::vector<int> temp_levels(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            if (level > max_level) {\n                max_level = level;\n            }\n        }\n        else if (chr == ')') {\n            level--;\n            if (level == 0) {\n                temp_levels[i] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n\n    all_levels.clear();\n    for (int value : temp_levels) {\n        if (value != 0) {\n            all_levels.push_back(value);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::string paren_string;\n    std::vector<int> result;\n\n    std::vector<int> expected1 = {2, 3, 1, 3};\n    std::vector<int> expected2 = {1, 2, 3, 4};\n    std::vector<int> expected3 = {4};\n    \n    paren_string = "(()()) ((())) () ((())()())";\n    parse_nested_parens(paren_string, result);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    paren_string = "() (()) ((())) (((())))";\n    parse_nested_parens(paren_string, result);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    paren_string = "(()(())((())))";\n    parse_nested_parens(paren_string, result);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}\n```\n\n### Explanation\n- **parse_nested_parens function**:\n  - Parses a string of nested parentheses and calculates the nesting levels.\n  - Uses vectors to dynamically store the nesting levels.\n  - The function iterates through the characters of the parenthesis string, tracking the current nesting level and the maximum nesting level encountered.\n  - Tracks levels and then filters out any zeros, storing only the depths of complete parenthesis sequences.\n\n- **issame function**:\n  - Compares two vectors to determine if they are the same by comparing their sizes and elements.\n\n- **Main program**:\n  - Initialize the test cases and their expected outputs.\n  - Calls the `parse_nested_parens` function for each test case and check results using `issame`.\n  - Prints an error message and exits with a status code if any of the tests fail.
Sure! Here is the equivalent C++ code for the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\n// Utility functions\nnamespace utils {\n\n    std::vector<int> sum_product(const std::vector<int>& numbers) {\n        int sum = 0;\n        int product = 1;\n\n        for (int num : numbers) {\n            sum += num;\n            product *= num;\n        }\n\n        return {sum, product};\n    }\n\n    bool issame(const std::vector<int>& a, const std::vector<int>& b) {\n        if (a.size() != b.size()) {\n            return false;\n        }\n\n        for (std::size_t i = 0; i < a.size(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// Test cases in the main function\nint main() {\n    std::vector<int> result;\n    std::vector<int> empty_array;\n    std::vector<int> array1 = {1, 1, 1};\n    std::vector<int> array2 = {100, 0};\n    std::vector<int> array3 = {3, 5, 7};\n    std::vector<int> array4 = {10};\n\n    // Test case 1\n    result = utils::sum_product(empty_array);\n    if (!utils::issame(result, {0, 1})) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    result = utils::sum_product(array1);\n    if (!utils::issame(result, {3, 1})) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    result = utils::sum_product(array2);\n    if (!utils::issame(result, {100, 0})) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    result = utils::sum_product(array3);\n    if (!utils::issame(result, {3 + 5 + 7, 3 * 5 * 7})) {\n        std::cerr << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    result = utils::sum_product(array4);\n    if (!utils::issame(result, {10, 10})) {\n        std::cerr << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Sum and Product Function (`sum_product`)**:\n    - The `sum_product` function in C++ calculates the sum and product of elements in a `std::vector<int>`.\n    - It returns a `std::vector<int>` containing the sum and product.\n\n2. **Array Comparison Function (`issame`)**:\n    - The `issame` function in C++ checks if two `std::vector<int>` arrays are the same in terms of size and content.\n\n3. **Main Function**:\n    - The main function initializes test cases and checks the results using the utility functions.\n    - If any test case fails, an appropriate message is displayed, and the program exits with an error.\n\n### Notes:\n- In C++, vectors are dynamically resizable, so there's no need to manually allocate or deallocate arrays as in Fortran.\n- The `issame` function uses the `std::vector<int>`'s `size()` method to get the size of the array.\n- `std::cerr` is used to print error messages and `std::endl` to ensure a newline is printed.\n- `std::vector<int> empty_array;` is equivalent to allocating an empty array in Fortran.
Sure, below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Rolling max function\nvoid rolling_max(const std::vector<int>& numbers, std::vector<int>& out) {\n    out.resize(numbers.size());\n    int max = 0;\n    for (std::size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (std::size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\n// Test assert function\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> numbers, result, expected;\n\n    // Test case 1\n    numbers.clear();\n    expected.clear();\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 2\n    numbers = {1, 2, 3, 4};\n    expected = {1, 2, 3, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 3\n    numbers = {4, 3, 2, 1};\n    expected = {4, 4, 4, 4};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    // Test case 4\n    numbers = {3, 2, 3, 100, 3};\n    expected = {3, 3, 3, 100, 100};\n    rolling_max(numbers, result);\n    assert_condition(issame(result, expected));\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definitions**:\n    - `rolling_max` function translates the Fortran subroutine of the same name.\n    - `issame` function translates the Fortran logical function for vector comparison.\n    - `assert_condition` function translates the Fortran subroutine for assertion.\n\n2. **Main Function**:\n    - The main function runs the specified test cases just like in the Fortran program, applying `rolling_max` to `numbers` and checking if the result matches `expected` using `issame`, and asserting the results using `assert_condition`.\n\n3. **Vector Management**:\n    - In Fortran, arrays were dynamically allocated and deallocated using `allocate` and `deallocate`. In C++, `std::vector` automatically handles dynamic memory.\n\n4. **Comparison and Assertions**:\n    - The `issame` function checks for element-wise equality of vectors and their sizes. \n    - `assert_condition` uses a simple boolean assertion, and if the condition fails, the program exits with an error message. This mimics the `assert` subroutine in Fortran.\n\nThis complete program should function similarly to the Fortran code and produce equivalent results.
Below is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function prototypes\nbool is_palindrome(const std::string &str);\nstd::string make_palindrome(const std::string &str);\nstd::string reverse_string(const std::string &str);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(make_palindrome("") == "");\n    assert(make_palindrome("x") == "x");\n    assert(make_palindrome("xyz") == "xyzyx");\n    assert(make_palindrome("xyx") == "xyx");\n    assert(make_palindrome("jerry") == "jerryrrej");\n\n    std::cout << "All tests passed!" << std::endl;\n\n    return 0;\n}\n\nbool is_palindrome(const std::string &str) {\n    std::string reversed_str = reverse_string(str);\n    return str == reversed_str;\n}\n\nstd::string make_palindrome(const std::string &str) {\n    for (size_t i = 0; i < str.length(); ++i) {\n        std::string rstr = str.substr(i);\n        if (is_palindrome(rstr)) {\n            std::string nstr = str.substr(0, i);\n            std::string n2str = reverse_string(nstr);\n            return str + n2str;\n        }\n    }\n\n    std::string n2str = reverse_string(str);\n    return str + n2str;\n}\n\nstd::string reverse_string(const std::string &str) {\n    std::string reversed_str = str;\n    std::reverse(reversed_str.begin(), reversed_str.end());\n    return reversed_str;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n```\n\nExplanation:\n1. The C++ version uses standard library functions and containers such as `std::string`.\n2. The `make_palindrome`, `reverse_string`, `is_palindrome`, and `assert` functions have been implemented similarly to their Fortran counterparts.\n3. The `reverse_string` function uses `std::reverse` from the `<algorithm>` library.\n4. The main function contains the test cases, using `assert` to check the expected outcomes.
Here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit()\n\nstd::string string_xor(const std::string &a, const std::string &b) {\n    size_t len_a = a.size();\n    size_t len_b = b.size();\n    size_t min_len = std::min(len_a, len_b);\n    std::string output;\n\n    for (size_t i = 0; i < min_len; ++i) {\n        if (a[i] == b[i]) {\n            output += '0';\n        } else {\n            output += '1';\n        }\n    }\n\n    if (len_a > len_b) {\n        output += a.substr(min_len);\n    } else if (len_b > len_a) {\n        output += b.substr(min_len);\n    }\n\n    return output;\n}\n\nint main() {\n    std::string result;\n\n    // Test case 1\n    result = string_xor("111000", "101010");\n    if (result != "010010") {\n        std::cerr << "Assertion failed: string_xor('111000', '101010') != '010010'" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    result = string_xor("1", "1");\n    if (result != "0") {\n        std::cerr << "Assertion failed: string_xor('1', '1') != '0'" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    result = string_xor("0101", "0000");\n    if (result != "0101") {\n        std::cerr << "Assertion failed: string_xor('0101', '0000') != '0101'" << std::endl;\n        return 1;\n    }\n\n    // If all tests pass\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function Definition**:\n   - The `string_xor` function accepts two strings (`a` and `b`) and computes their XOR-result string. It goes character by character, comparing the two input strings.\n   - If the characters at the same position in the two input strings are the same, '0' is appended to the result. Otherwise, '1' is appended.\n   - After processing the common length of the two strings, the remainder of the longer string is appended to the result.\n\n2. **Main Function**:\n   - The `main` function contains test cases similar to those in the Fortran code.\n   - Each test case compares the result of the `string_xor` function with the expected result, and if any test fails, it prints an error message and exits with a status code of 1.\n\n3. **Standard Output**:\n   - If all tests pass, a success message is displayed: "All tests passed!".\n\nThis C++ code provides equivalent functionality to the original Fortran code, handling string manipulation and test cases with appropriate assertions.
Sure, here is the equivalent C++ code for the given Fortran module:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to trim trailing spaces\nstd::string trim(const std::string& str) {\n    size_t end = str.find_last_not_of(" ");\n    return (end == std::string::npos) ? "" : str.substr(0, end + 1);\n}\n\n// Function to find the longest string\nstd::string longest(const std::vector<std::string>& strings) {\n    std::string out;\n    for (const auto& str : strings) {\n        if (trim(str).size() > trim(out).size()) {\n            out = str;\n        }\n    }\n    return out;\n}\n\nint main() {\n    std::vector<std::string> strings;\n    std::string result;\n\n    // Test case 1: Empty array\n    strings = {};\n    result = longest(strings);\n    if (result != "") {\n        std::cout << "Test case 1 failed: assertion failed\n";\n        return 1;\n    }\n\n    // Test case 2: Array with single character strings\n    strings = {"x", "y", "z"};\n    result = longest(strings);\n    if (result != "x") {\n        std::cout << "Test case 2 failed: assertion failed\n";\n        return 1;\n    }\n\n    // Test case 3: Array with varying length strings\n    strings = {"x       ", "yyy     ", "zzzz    ", "www     ", "kkkk    ", "abc     "};\n    result = longest(strings);\n    if (result != "zzzz    ") {\n        std::cout << "Test case 3 failed: assertion failed\n";\n        return 1;\n    }\n\n    std::cout << "All test cases passed\n";\n    return 0;\n}\n```\n\nIn the provided C++ code:\n- `trim` is a helper function that trims trailing spaces from a string.\n- `longest` is the function that takes a vector of strings and returns the longest string.\n- The main function contains the test cases, analogous to the Fortran test cases.\n\nNote:\n- In C++ we use `std::vector` for dynamic arrays.\n- Strings in C++ are managed by the `std::string` class.\n- Allocation and deallocation are automatically managed by `std::vector` and `std::string`, respectively.\n- The test cases are implemented using simple `if` statements instead of the `write` and `exit` Fortran statements.
Certainly! Here is the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <cstdlib>  // For std::exit\n\n// Function to calculate the greatest common divisor (GCD) using Euclid's algorithm\nint greatest_common_divisor(int a, int b) {\n    int temp_a = a;\n    int temp_b = b;\n    int m;\n\n    while (true) {\n        if (temp_a < temp_b) {\n            m = temp_a;\n            temp_a = temp_b;\n            temp_b = m;\n        }\n        temp_a = temp_a % temp_b;\n        if (temp_a == 0) {\n            return temp_b;\n        }\n    }\n}\n\n// Function to assert conditions with a failure message\nvoid assert_condition(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases for the gcd function\n    assert_condition(greatest_common_divisor(3, 7) == 1, "Assertion failed: gcd(3, 7) == 1");\n    assert_condition(greatest_common_divisor(10, 15) == 5, "Assertion failed: gcd(10, 15) == 5");\n    assert_condition(greatest_common_divisor(49, 14) == 7, "Assertion failed: gcd(49, 14) == 7");\n    assert_condition(greatest_common_divisor(144, 60) == 12, "Assertion failed: gcd(144, 60) == 12");\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `greatest_common_divisor`**:\n   - Translates the GCD calculation from Fortran to C++.\n   - Uses Euclid's algorithm for GCD computation via a `while (true)` loop, similar to the Fortran `do` loop.\n\n2. **Function `assert_condition`**:\n   - Checks the condition, outputs an error message, and exits if the assertion fails. This is similar to the `assert` subroutine in Fortran.\n\n3. **`main` function**:\n   - Contains some test cases for `greatest_common_divisor`, checking that the results are as expected, similar to what is provided in the Fortran `main` program.\n\nThis C++ program should behave similarly to the described Fortran program and should provide the same functionality for GCD computation and assertion testing.
Here's the Fortran program translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// Function declarations\nstd::vector<std::string> all_prefixes(const std::string& str);\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b);\n\nint main() {\n    // Test cases\n    std::vector<std::string> expected;\n    std::string str = "";\n\n    // Test case 1\n    auto prefixes = all_prefixes(str);\n    expected = {""};\n    assert(issame(prefixes, expected));\n\n    // Test case 2\n    str = "asdfgh";\n    expected = {"a", "as", "asd", "asdf", "asdfg", "asdfgh"};\n    prefixes = all_prefixes(str);\n    assert(issame(prefixes, expected));\n\n    // Test case 3\n    str = "WWW";\n    expected = {"W", "WW", "WWW"};\n    prefixes = all_prefixes(str);\n    assert(issame(prefixes, expected));\n\n    std::cout << "All tests passed!" << std::endl;\n\n    return 0;\n}\n\nstd::vector<std::string> all_prefixes(const std::string& str) {\n    std::vector<std::string> out;\n    std::string current = "";\n\n    if (str.empty()) {\n        out.push_back("");\n        return out;\n    }\n\n    for (char ch : str) {\n        current += ch;\n        out.push_back(current);\n    }\n\n    return out;\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\nLetâ€™s break down what was done to convert the Fortran code into C++:\n\n1. **Main Function:**\n    - The main program in Fortran was converted into the `main()` function in C++.\n    - The Fortran way of clearing and allocating memory was replaced with appropriate C++ `std::vector` and `std::string` usage.\n\n2. **Routine Conversion:**\n    - The subroutine `all_prefixes` is now a C++ function `all_prefixes`.\n    - The function generates all the prefixes of the input string and stores them in a `std::vector<std::string>`.\n    - If the string is empty, it returns a single-element vector with an empty string.\n\n3. **Logical Operation:**\n    - The function `issame` checks if two vectors of strings contain the same elements, similar to its Fortran counterpart.\n\n4. **Assertion:**\n    - Instead of writing our own `assert` function, we use the built-in `assert` provided by C++ in the `<cassert>` library.\n    - When an assertion fails, the program will show an error and terminate immediately, mirroring the behavior of the Fortran `assert` subroutine.\n\n5. **Testing:**\n    - The testing of functions is identical here, ensuring the results of `all_prefixes` match the expected outcomes by using assertions.\n\nThe translated C++ code maintains the same logic and structure as the original Fortran program, leveraging C++'s powerful standard library for handling strings and dynamic arrays.
Here's the Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstdlib>\n\nstd::string string_sequence(int n) {\n    std::ostringstream oss;\n\n    // Initialize with "0"\n    oss << "0";\n    for (int i = 1; i <= n; ++i) {\n        oss << " " << i;\n    }\n\n    return oss.str();\n}\n\nvoid assert_string_sequence(int n, const std::string& expected) {\n    std::string result = string_sequence(n);\n    if (result != expected) {\n        std::cerr << "Assertion failed: string_sequence(" << n << ") == '" << expected << "'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_string_sequence(0, "0");\n    assert_string_sequence(3, "0 1 2 3");\n    assert_string_sequence(10, "0 1 2 3 4 5 6 7 8 9 10");\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **`string_sequence` function**:\n    - Uses an `std::ostringstream` to build the string sequence.\n    - Starts with `0` and appends numbers from `1` to `n`.\n\n2. **`assert_string_sequence` function**:\n    - Tests the result of `string_sequence` against the expected value.\n    - If the result does not match the expected value, an error message is displayed, and the program exits with a failure status code.\n\n3. **`main` function**:\n    - Calls `assert_string_sequence` with different test cases.\n    - If all tests pass, a success message is printed to the console.
Sure! Here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cctype>\n\nint count_distinct_characters(const std::string& str) {\n    std::set<char> distinct_chars;\n    for (char c : str) {\n        char lower_c = std::tolower(static_cast<unsigned char>(c));\n        distinct_chars.insert(lower_c);\n    }\n    return distinct_chars.size();\n}\n\nint main() {\n    std::string str;\n    int result;\n\n    // Test cases\n    str = "";\n    result = count_distinct_characters(str);\n    if (result != 0) {\n        std::cerr << "Assertion failed: count_distinct_characters('') == 0" << std::endl;\n        return 1;\n    }\n\n    str = "abcde";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcde') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "abcdecadeCADE";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('abcdecadeCADE') == 5" << std::endl;\n        return 1;\n    }\n\n    str = "aaaaAAAAaaaa";\n    result = count_distinct_characters(str);\n    if (result != 1) {\n        std::cerr << "Assertion failed: count_distinct_characters('aaaaAAAAaaaa') == 1" << std::endl;\n        return 1;\n    }\n\n    str = "Jerry jERRY JeRRRY";\n    result = count_distinct_characters(str);\n    if (result != 5) {\n        std::cerr << "Assertion failed: count_distinct_characters('Jerry jERRY JeRRRY') == 5" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nIn this C++ version, I use the `std::set` container to keep track of distinct characters and the `<algorithm>` and `<cctype>` libraries for character manipulation. This code maintains the structure of the original Fortran code and correctly handles the assertion checks.
Here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid append(vector<int>& array, int value) {\n    array.push_back(value);\n}\n\nbool issame(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    cout << "Comparing arrays: ";\n    for (const int &val : a) cout << val << " ";\n    cout << " and ";\n    for (const int &val : b) cout << val << " ";\n    cout << " Result: true" << endl;\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cerr << "Assertion failed" << endl;\n        exit(1);\n    }\n}\n\nvector<int> parse_music(const string& music_string) {\n    vector<int> result;\n    stringstream ss(music_string);\n    string token;\n    \n    while (ss >> token) {\n        if (token == "o") {\n            append(result, 4);\n        } else if (token == "o|") {\n            append(result, 2);\n        } else if (token == ".|") {\n            append(result, 1);\n        }\n    }\n    \n    cout << "Parsed music string: ";\n    for (const int &val : result) cout << val << " ";\n    cout << endl;\n    \n    return result;\n}\n\nint main() {\n    vector<int> empty_array;\n\n    // Test cases\n    assert(issame(parse_music(""), empty_array));\n    assert(issame(parse_music("o o o o"), {4, 4, 4, 4}));\n    assert(issame(parse_music(".| .| .| .|"), {1, 1, 1, 1}));\n    assert(issame(parse_music("o| o| .| .| o o o o"), {2, 2, 1, 1, 4, 4, 4, 4}));\n    assert(issame(parse_music("o| .| o| .| o o| o o|"), {2, 1, 2, 1, 4, 2, 4, 2}));\n\n    return 0;\n}\n```\n\nHere is a brief explanation of how the code is structured:\n\n1. **Append Function**: The `append` function in C++ uses `push_back` to append a value to the vector.\n2. **IsSame Function**: It checks if two vectors are equal.\n3. **Assert Function**: Checks the condition and exits the program if the condition is false.\n4. **Parse Music Function**: Parses the music string and stores results in a vector.\n\nThese functions mirror the original Fortran functionality, translated into C++ idioms. Note that C++ uses standard libraries for vector manipulations and string processing, making the code more concise compared to Fortran.
Here is the Fortran code translated into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint how_many_times(const std::string& str, const std::string& substring) {\n    int out = 0;\n    int str_len = str.size();\n    int sub_len = substring.size();\n\n    if (str_len == 0) {\n        return 0;\n    }\n\n    for (int i = 0; i <= str_len - sub_len; ++i) {\n        if (str.substr(i, sub_len) == substring) {\n            out++;\n        }\n    }\n\n    return out;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n\n    result = how_many_times("", "x");\n    if (result != 0) {\n        std::cerr << "Assertion failed: how_many_times('', 'x') == 0" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("xyxyxyx", "x");\n    if (result != 4) {\n        std::cerr << "Assertion failed: how_many_times('xyxyxyx', 'x') == 4" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("cacacacac", "cac");\n    if (result != 4) {\n        std::cerr << "Assertion failed: how_many_times('cacacacac', 'cac') == 4" << std::endl;\n        return 1;\n    }\n\n    result = how_many_times("john doe", "john");\n    if (result != 1) {\n        std::cerr << "Assertion failed: how_many_times('john doe', 'john') == 1" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Key changes made during translation:\n1. **Modules and Functions**:\n   - The `module` and `contains` structure from Fortran are replaced by standard C++ function declarations.\n   - The `how_many_times` function is translated into a C++ function `how_many_times`.\n\n2. **Strings**:\n   - Fortran strings are translated to `std::string` objects in C++.\n\n3. **Loops and Conditions**:\n   - The Fortran `do` loop is replaced by a `for` loop.\n   - Conditional checks `if` remain mostly unchanged.\n\n4. **Test Cases**:\n   - Fortran's `write` and `call exit` are replaced with C++ `std::cerr` for error messages and `std::cout` for the final success message. The `exit` function is replaced by returning `1` from `main()` to indicate a failure, and returning `0` otherwise.\n\n### Note:\nError handling is performed using `std::cerr` to print an error message and returning `1` from `main()` to indicate a failure. This is a direct translation of the Fortran behavior.
Sure! Here's the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n#include <algorithm>\n\n// Function to find the closest elements\nstd::vector<float> find_closest_elements(const std::vector<float>& numbers) {\n    std::vector<float> out(2, 0.0f);\n    float min_diff = std::numeric_limits<float>::max();\n\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n                min_diff = diff;\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        std::swap(out[0], out[1]);\n    }\n\n    return out;\n}\n\n// Function to compare two arrays for similarity\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    const float tolerance = 1e-4;\n\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > tolerance) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<float> test1 = {1.0f, 2.0f, 3.9f, 4.0f, 5.0f, 2.2f};\n    std::vector<float> test2 = {1.0f, 2.0f, 5.9f, 4.0f, 5.0f};\n    std::vector<float> test3 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.2f};\n    std::vector<float> test4 = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 2.0f};\n    std::vector<float> test5 = {1.1f, 2.2f, 3.1f, 4.1f, 5.1f};\n\n    std::vector<float> result = find_closest_elements(test1);\n    if (!issame(result, {3.9f, 4.0f})) {\n        std::cerr << "Assertion failed for test1" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test2);\n    if (!issame(result, {5.0f, 5.9f})) {\n        std::cerr << "Assertion failed for test2" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test3);\n    if (!issame(result, {2.0f, 2.2f})) {\n        std::cerr << "Assertion failed for test3" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test4);\n    if (!issame(result, {2.0f, 2.0f})) {\n        std::cerr << "Assertion failed for test4" << std::endl;\n        return 1;\n    }\n\n    result = find_closest_elements(test5);\n    if (!issame(result, {2.2f, 3.1f})) {\n        std::cerr << "Assertion failed for test5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\nThis C++ code performs the same operations as the Fortran code:\n1. `find_closest_elements` finds the two closest elements in an array.\n2. `issame` checks if two arrays are similar within a small tolerance.\n\nThe `main` function runs tests on several data sets and outputs whether the tests passed or failed.
Here is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nstd::vector<float> rescale_to_unit(const std::vector<float>& numbers) {\n    std::vector<float> rescaled;\n    if (numbers.empty())\n        return rescaled;\n\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\n    for (float number : numbers) {\n        rescaled.push_back((number - min_val) / (max_val - min_val));\n    }\n\n    return rescaled;\n}\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size())\n        return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::fabs(a[i] - b[i]) > 1.0e-4)\n            return false;\n    }\n\n    return true;\n}\n\nint main() {\n    // Expected results\n    std::vector<float> expected1 = {0.0, 1.0};\n    std::vector<float> expected2 = {1.0, 0.0};\n    std::vector<float> expected3 = {0.0, 0.25, 0.5, 0.75, 1.0};\n    std::vector<float> expected4 = {0.25, 0.0, 1.0, 0.5, 0.75};\n    std::vector<float> expected5 = {0.25, 0.0, 1.0, 0.5, 0.75};\n\n    // Test case 1\n    std::vector<float> numbers1 = {2.0, 49.9};\n    std::vector<float> result = rescale_to_unit(numbers1);\n    if (!issame(result, expected1)) {\n        std::cerr << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<float> numbers2 = {100.0, 49.9};\n    result = rescale_to_unit(numbers2);\n    if (!issame(result, expected2)) {\n        std::cerr << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    std::vector<float> numbers3 = {1.0, 2.0, 3.0, 4.0, 5.0};\n    result = rescale_to_unit(numbers3);\n    if (!issame(result, expected3)) {\n        std::cerr << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    std::vector<float> numbers4 = {2.0, 1.0, 5.0, 3.0, 4.0};\n    result = rescale_to_unit(numbers4);\n    if (!issame(result, expected4)) {\n        std::cerr << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    std::vector<float> numbers5 = {12.0, 11.0, 15.0, 13.0, 14.0};\n    result = rescale_to_unit(numbers5);\n    if (!issame(result, expected5)) {\n        std::cerr << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed successfully" << std::endl;\n    return 0;\n}\n```\n\nHere are the key points in the C++ code:\n1. **`rescale_to_unit` function:** It rescales the input vector of numbers to a unit scale between 0 and 1.\n2. **`issame` function:** It checks if two vectors are the same with a permissible difference of `1.0e-4` (to match floating-point precision).\n3. **Main function:** It defines some test cases and compares the results of the rescaling against expected results. If any of the test cases fail, it prints an error message and exits with an error code. If all test cases pass, it prints a success message.\n\nMake sure to include the proper libraries and compile the code using a C++11 compatible compiler.
Certainly! Below is the equivalent C++ code that performs the same logic:\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n\n// Function to get the length of a string\nint strlen_custom(const std::string& str) {\n    return str.length();\n}\n\nvoid run_assertions() {\n    // Assertions\n    if (strlen_custom("") != 0) {\n        std::cerr << "Assertion failed: strlen(\"\") == 0" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen_custom("x") != 1) {\n        std::cerr << "Assertion failed: strlen(\"x\") == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (strlen_custom("asdasnakj") != 9) {\n        std::cerr << "Assertion failed: strlen(\"asdasnakj\") == 9" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    // Main program logic\n    run_assertions();\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `strlen_custom`**:\n    - The function `int strlen_custom(const std::string& str)` in C++ takes a `std::string` and returns its length using the `.length()` method.\n\n2. **Assertions in `run_assertions`**:\n    - Here, we use `if` statements to compare the return value of `strlen_custom` with expected values.\n    - If an assertion fails, we print an error message to `std::cerr` and use `std::exit(1)` to terminate the program with a non-zero exit code.\n\n3. **Main Program**:\n    - The `main` function calls `run_assertions` to perform the tests.\n\n### Additional Notes:\n- In C++, we use the `std::string` class to handle strings, which automatically manages memory and provides convenient methods such as `.length()`.\n- For input and output, we use `std::cout` and `std::cerr` from the C++ standard library `<iostream>`.\n- Error handling and program termination are managed using `std::exit` from `<cstdlib>`, which is analogous to the `call exit` statement in Fortran.
Sure, here is the corresponding C++ code that replicates the logic from your Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_divisor(int n);\n\nint main() {\n    int result;\n\n    // Test cases\n    result = largest_divisor(3);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(3) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(7);\n    if (result != 1) {\n        std::cerr << "Assertion failed: largest_divisor(7) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(10);\n    if (result != 5) {\n        std::cerr << "Assertion failed: largest_divisor(10) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(100);\n    if (result != 50) {\n        std::cerr << "Assertion failed: largest_divisor(100) == 50" << std::endl;\n        std::exit(1);\n    }\n\n    result = largest_divisor(49);\n    if (result != 7) {\n        std::cerr << "Assertion failed: largest_divisor(49) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n\nint largest_divisor(int n) {\n    for (int i = 2; i <= std::sqrt(static_cast<double>(n)); ++i) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```\n\nHere's a brief explanation of each part of the C++ code:\n\n1. **`#include` Directives**: These include the necessary headers for input/output operations and mathematical functions.\n\n2. **Function Declaration for `largest_divisor`**: Just like in Fortran, this function is defined later in the code but declared at the start so that `main` can call it.\n\n3. **Main Function**:\n    - Runs the test cases similar to the Fortran code.\n    - Checks the result of `largest_divisor` and compares it with the expected value.\n    - Prints error messages and exits the program if an assertion fails.\n\n4. **Definition of `largest_divisor` Function**:\n    - Calculates the largest divisor of `n` by iterating from 2 up to the square root of `n`.\n    - If a divisor is found, it returns `n` divided by the divisor.\n    - If no divisors are found, it returns 1.
Below is the given Fortran code translated into C++. The C++ version uses standard C++ libraries and constructs:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\n// Function prototypes\nstd::vector<int> factorize(int n);\nvoid append(std::vector<int>& arr, int value);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\n\nint main() {\n    std::vector<int> factors;\n    bool result;\n    \n    factors = factorize(2);\n    result = issame(factors, {2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(2)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(4);\n    result = issame(factors, {2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(4)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(8);\n    result = issame(factors, {2, 2, 2});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(8)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(3 * 19);\n    result = issame(factors, {3, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(3 * 19 * 3 * 19);\n    result = issame(factors, {3, 3, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(3 * 19 * 3 * 19 * 3 * 19);\n    result = issame(factors, {3, 3, 3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 3 * 19 * 3 * 19)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(3 * 19 * 19 * 19);\n    result = issame(factors, {3, 19, 19, 19});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 19 * 19 * 19)" << std::endl;\n        return 1;\n    }\n\n    factors = factorize(3 * 2 * 3);\n    result = issame(factors, {2, 3, 3});\n    if (!result) {\n        std::cerr << "Assertion failed for factorize(3 * 2 * 3)" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    int m = n;\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (m <= 1) break;\n        while (m % i == 0) {\n            m /= i;\n            append(factors, i);\n        }\n    }\n\n    if (m > 1) {\n        append(factors, m);\n    }\n\n    return factors;\n}\n\nvoid append(std::vector<int>& arr, int value) {\n    arr.push_back(value);\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n```\n\n### Explanation:\n1. **Function Prototypes:**\n   - Declares the `factorize`, `append`, and `issame` functions before `main`.\n\n2. **Main Function:**\n   - Tests the `factorize` function with different inputs and compares the results against expected values using `issame`.\n\n3. **Factorize Function:**\n   - Uses a vector to store factors, similar to the Fortran code using an allocatable array.\n   - Loops through possible factors from 2 up to the square root of `n` and appends each factor to the vector.\n\n4. **Append Function:**\n   - Mimics the Fortran `append` subroutine. In C++, vector's `push_back` is used to add elements.\n\n5. **IsSame Function:**\n   - Compares two vectors for equality element-wise.
Sure, here is the translation of the given Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass RemoveDuplicatesProgram {\npublic:\n    static void run() {\n        // Test cases\n        assert(issame(remove_duplicates({1, 2, 3, 4}), {1, 2, 3, 4}));\n        assert(issame(remove_duplicates({1, 2, 3, 2, 4, 3, 5}), {1, 4, 5}));\n        assert(issame(remove_duplicates({}), {}));\n    }\n\nprivate:\n    static std::vector<int> remove_duplicates(const std::vector<int>& numbers) {\n        std::vector<int> has1;\n        std::vector<int> has2;\n        std::vector<int> out;\n\n        if (numbers.empty()) {\n            return out;\n        }\n\n        for (int num : numbers) {\n            bool found = (std::find(has2.begin(), has2.end(), num) != has2.end());\n            if (found) continue;\n\n            found = (std::find(has1.begin(), has1.end(), num) != has1.end());\n            if (found) {\n                append(has2, num);\n            } else {\n                append(has1, num);\n            }\n        }\n\n        for (int num : numbers) {\n            bool found = (std::find(has2.begin(), has2.end(), num) != has2.end());\n            if (!found) {\n                append(out, num);\n            }\n        }\n\n        return out;\n    }\n\n    static void append(std::vector<int>& array, int value) {\n        array.push_back(value);\n    }\n\n    static bool issame(const std::vector<int>& a, const std::vector<int>& b) {\n        if (a.size() != b.size()) {\n            return false;\n        }\n        for (size_t i = 0; i < a.size(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static void assert(bool condition) {\n        if (!condition) {\n            std::cerr << "Assertion failed" << std::endl;\n            std::exit(1);\n        }\n    }\n};\n\nint main() {\n    RemoveDuplicatesProgram::run();\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Class `RemoveDuplicatesProgram`**:\n   - Contains the `run` method to execute the test cases.\n   - Uses `assert`, `remove_duplicates`, `append`, and `issame` methods as member functions to reflect the structure of the Fortran program.\n\n2. **Test Cases**:\n   - Calls to `assert` are transformed into test cases in the `run` method.\n\n3. **Remove Duplicates Method**:\n   - Translates the logic inside the `remove_duplicates` method to handle duplicates as in Fortran.\n   - Uses C++ standard algorithms like `std::find` to check for existence.\n\n4. **Append Method**:\n   - Uses `std::vector::push_back` to append elements as `std::vector` naturally manages dynamic resizing.\n\n5. **issame Method**:\n   - Compares two `std::vector<int>` for equality in a similar way to the Fortran code.\n\n6. **Assertion Method**:\n   - Mimics Fortranâ€™s `assert` to ensure the correctness of test cases.\n\nThe resulting C++ code uses C++ `std::vector` for dynamic array handling and incorporates the structure and logic from the Fortran program.
Sure! Below is the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cctype>\n#include <cassert>\n\n// Function to flip case of characters in a string\nstd::string flip_case(const std::string& str) {\n    std::string out;\n    for (char c : str) {\n        if (std::islower(c)) {\n            out += std::toupper(c);\n        }\n        else if (std::isupper(c)) {\n            out += std::tolower(c);\n        }\n        else {\n            out += c;\n        }\n    }\n    return out;\n}\n\n// Main program\nint main() {\n    // Test cases\n    assert(flip_case("") == "");\n    assert(flip_case("Hello!") == "hELLO!");\n    assert(flip_case("These violent delights have violent ends") == "tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS");\n\n    std::cout << "All test cases passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n#### flip_case Function:\n1. **Function Signature:** The function `flip_case` takes a constant reference to a `std::string` and returns a `std::string`.\n2. **Loop Through Characters:** It loops through each character in the input string.\n3. **Character Case Conversion:** It uses `std::islower` and `std::toupper` for converting lowercase to uppercase, and `std::isupper` and `std::tolower` for converting uppercase to lowercase.\n4. **Non-Alphabetic Characters:** Non-alphabetic characters are appended to the output string without modification.\n\n#### Main Function:\n1. **Assertions:** The `assert` function is used to check conditions. If an assertion fails, the program will terminate, printing an error message.\n2. **Test Cases:** It includes three test cases to verify the correctness of the `flip_case` function.\n3. **Successful Test Output:** If all assertions pass, the message "All test cases passed!" is printed.\n\nThe use of standard library functions like `std::isupper`, `std::islower`, `std::toupper`, and `std::tolower` simplifies the implementation compared to the character code manipulation in Fortran.
Sure, here is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\n// Function to concatenate vector of strings\nstd::string concatenate(const std::vector<std::string>& strings) {\n    std::string result;\n    for (const auto& str : strings) {\n        result += str;\n    }\n    return result;\n}\n\nint main() {\n    std::vector<std::string> strings;\n    std::string result;\n\n    // Test with an empty array\n    strings.clear();\n    result = concatenate(strings);\n    if (result != "") {\n        std::cerr << "Assertion failed: concatenate([]) != ''" << std::endl;\n        std::exit(1);\n    }\n\n    // Test with an array of strings\n    strings = {"x", "y", "z"};\n    result = concatenate(strings);\n    if (result != "xyz") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z']) != 'xyz'" << std::endl;\n        std::exit(1);\n    }\n\n    // Test with a larger array of strings\n    strings = {"x", "y", "z", "w", "k"};\n    result = concatenate(strings);\n    if (result != "xyzwk") {\n        std::cerr << "Assertion failed: concatenate(['x', 'y', 'z', 'w', 'k']) != 'xyzwk'" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nKey details of the translation:\n1. The main program structure and flow remain the same.\n2. `std::vector<std::string>` is used to handle dynamic arrays of strings.\n3. The `concatenate` function takes a `std::vector<std::string>` and returns the concatenated result.\n4. For testing and assertion failures, `std::cerr` and `std::exit` are used. The standard I/O functions and exit function from `cstdlib` are used to match the Fortran behavior.\n
Translating Fortran code to C++ involves some significant changes, especially in the way arrays and strings are handled. Here's a rough C++ translation for the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\n// Function to filter strings by prefix\nstd::vector<std::string> filter_by_prefix(const std::vector<std::string>& strings, const std::string& prefix) {\n    std::vector<std::string> out;\n    for (const auto& str : strings) {\n        if (str.substr(0, prefix.size()) == prefix) {\n            out.push_back(str);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vector of strings are identical\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\n// Function to run test cases\nvoid test_cases() {\n    std::vector<std::string> strings;\n    std::string prefix;\n    std::vector<std::string> result;\n    std::vector<std::string> expected;\n\n    // Test case 1\n    strings.clear();\n    prefix = "john";\n    result = filter_by_prefix(strings, prefix);\n    if (!issame(result, strings)) {\n        std::cerr << "Assertion failed: filter_by_prefix({}, 'john')" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    strings = {"xxx     ", "asd     ", "xxy     ", "john doe", "xxxAAA  ", "xxx     "};\n    prefix = "xxx";\n    result = filter_by_prefix(strings, prefix);\n    expected = {"xxx     ", "xxxAAA  ", "xxx     "};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: filter_by_prefix({'xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'}, 'xxx')" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    test_cases();\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nKey Points:\n1. **Vector and String Usage**:\n    - In C++, we use `std::vector<std::string>` instead of allocatable Fortran arrays.\n    - Strings are managed using `std::string`.\n\n2. **Filtering Function**:\n    - Use the `substr` method of `std::string` to check prefixes.\n\n3. **Adding Elements**:\n    - Instead of having a separate subroutine to add elements to an array, C++ `push_back` method of `std::vector` simplifies this process.\n\n4. **Equality Check**:\n    - A simple function `issame` compares the sizes and elements of two vectors.\n\n5. **Test Cases**:\n    - Test cases have been retained with the assertions modified to use `cerr` for error messages and `exit` function for handling test failures.\n\n6. **Main Function**:\n    - The `main` function calls `test_cases` and informs about the test results.\n\nThis translation should provide similar functionality to the original Fortran code.
To translate the provided Fortran code to C++, we need to handle dynamic arrays and provide similar functionality for the `get_positive` and `issame` functions. C++ handles arrays and dynamic memory allocation differently, usually through the use of the STL (Standard Template Library) vectors.\n\nHere is the equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n\n// Function to get positive elements from a vector\nstd::vector<float> get_positive(const std::vector<float>& l) {\n    std::vector<float> out;\n    for (float value : l) {\n        if (value > 0.0f) {\n            out.push_back(value);\n        }\n    }\n    return out;\n}\n\n// Function to check if two vectors are approximately the same\nbool issame(const std::vector<float>& a, const std::vector<float>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::abs(a[i] - b[i]) > 1.0e-4f) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<float> input, result, expected;\n    bool is_same;\n\n    // Test case 1\n    input = {-1.0f, -2.0f, 4.0f, 5.0f, 6.0f};\n    expected = {4.0f, 5.0f, 6.0f};\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cerr << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    input = {5.0f, 3.0f, -5.0f, 2.0f, 3.0f, 3.0f, 9.0f, 0.0f, 123.0f, 1.0f, -10.0f};\n    expected = {5.0f, 3.0f, 2.0f, 3.0f, 3.0f, 9.0f, 123.0f, 1.0f};\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cerr << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    input = {-1.0f, -2.0f};\n    expected.clear();\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cerr << "Test case 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    input.clear();\n    expected.clear();\n    result = get_positive(input);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cerr << "Test case 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **get_positive Function**:\n   - Uses a loop to iterate over the input vector `l`.\n   - Adds positive elements to the output vector `out`.\n\n2. **issame Function**:\n   - Checks if the sizes of the two vectors are the same.\n   - Compares each element of the vectors, ensuring the absolute difference between corresponding elements is within `1.0e-4`.\n\n3. **main Function**:\n   - Executes the test cases by setting up the `input` and `expected` vectors.\n   - Compares the result with the expected vector using the `issame` function.\n   - Prints an error message and exits if any test fails.\n   - Prints a success message if all tests pass.\n\nThis C++ implementation should provide the same functionality as the Fortran code you provided.
Certainly! Below is the equivalent C++ code for the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cmath>\n\n// Function to check if a number is prime\nbool is_prime(int n) {\n    if (n < 2) {\n        return false;\n    }\n    \n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid test_prime_check() {\n    // Assertions to test the is_prime function\n    if (!is_prime(6)) {\n        std::cerr << "Assertion failed: is_prime(6) == false" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(101)) {\n        std::cerr << "Assertion failed: is_prime(101) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(13441)) {\n        std::cerr << "Assertion failed: is_prime(13441) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(61)) {\n        std::cerr << "Assertion failed: is_prime(61) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(4)) {\n        std::cerr << "Assertion failed: is_prime(4) == false" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(1)) {\n        std::cerr << "Assertion failed: is_prime(1) == false" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(5)) {\n        std::cerr << "Assertion failed: is_prime(5) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(11)) {\n        std::cerr << "Assertion failed: is_prime(11) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(17)) {\n        std::cerr << "Assertion failed: is_prime(17) == true" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(5 * 17)) {\n        std::cerr << "Assertion failed: is_prime(5 * 17) == false" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(11 * 7)) {\n        std::cerr << "Assertion failed: is_prime(11 * 7) == false" << std::endl;\n        exit(1);\n    }\n\n    if (!is_prime(13441 * 19)) {\n        std::cerr << "Assertion failed: is_prime(13441 * 19) == false" << std::endl;\n        exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nint main() {\n    test_prime_check();\n    return 0;\n}\n```\n\nExplanation:\n1. The `is_prime` function in C++ does the same as the Fortran version. It checks if a given number `n` is prime by iterating from `2` to the square root of `n`.\n2. The `test_prime_check` function contains the assertions as in the Fortran `program`. It uses `std::cerr` to output error messages to standard error and `exit(1)` to terminate the program if an assertion fails.\n3. The `main` function simply calls `test_prime_check()` to perform the tests.\n\nTo compile and run this C++ code, you would use commands such as:\n```sh\ng++ -o test_prime_check test_prime_check.cpp\n./test_prime_check\n```
Here's the Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\ndouble poly(const std::vector<double>& xs, int n, double x) {\n    double sum = 0.0;\n    for (int i = 0; i < n; ++i) {\n        sum += xs[i] * std::pow(x, i);\n    }\n    return sum;\n}\n\ndouble find_zero(const std::vector<double>& xs, int n) {\n    double ans = 0.0;\n    double value = poly(xs, n, ans);\n    while (std::abs(value) > 1e-6) {\n        double driv = 0.0;\n        for (int i = 1; i < n; ++i) {\n            driv += xs[i] * i * std::pow(ans, i-1);\n        }\n        ans = ans - value / driv;\n        value = poly(xs, n, ans);\n    }\n    return ans;\n}\n\nint main() {\n    std::srand((unsigned)std::time(0));\n    \n    for (int i = 0; i < 100; ++i) {\n        int ncoeff = 2 * (1 + static_cast<int>(std::rand() / (RAND_MAX + 1.0) * 4));\n        std::vector<double> coeffs(ncoeff);\n\n        for (int j = 0; j < ncoeff; ++j) {\n            coeffs[j] = -10 + static_cast<int>(std::rand() / (RAND_MAX + 1.0) * 21);\n            if (coeffs[j] == 0)\n                coeffs[j] = 1;\n        }\n\n        double solution = find_zero(coeffs, ncoeff);\n        if (std::abs(poly(coeffs, ncoeff, solution)) >= 1e-3) {\n            std::cerr << "Assertion failed: abs(poly(coeffs, solution)) < 1e-3" << std::endl;\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n```\n\n### Detailed Explanation:\n1. **Header Inclusions and Namespaces**:\n   - `#include <iostream>`: For standard I/O operations.\n   - `#include <vector>`: For dynamic array handling similar to Fortran's array.\n   - `#include <cmath>`: For mathematical operations like power and absolute value.\n   - `#include <cstdlib>` and `#include <ctime>`: For random number generation.\n   - `using namespace std;` is avoided to prevent namespace pollution, although you could add it if preferred.\n\n2. **Poly Function**:\n   - Takes a `std::vector<double>` for coefficients and computes the polynomial value at `x` using summation of terms `xs[i] * pow(x, i)`.\n\n3. **Find Zero Function**:\n   - Uses the Newton-Raphson method to find a root of the polynomial.\n   - It repeatedly adjusts the estimate `ans` until the polynomial value at `ans` is sufficiently close to zero.\n\n4. **Main Program**:\n   - Initializes the random seed using `std::srand()`.\n   - The loop runs 100 iterations simulating the generation of random polynomial coefficients.\n   - It ensures that coefficients are non-zero, and it finds the polynomial root using the `find_zero` function.\n   - It checks if the calculated root indeed satisfies the polynomial equation to within a tolerance.\n\nThis C++ version maintains the same logic and functionality as the Fortran code and uses equivalent constructs available in C++.
Here is the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Function to sort an array of integers\nvoid sort_array(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to sort every third element of the given array\nstd::vector<int> sort_third(const std::vector<int>& l) {\n    const int n = l.size();\n    std::vector<int> third((n + 2) / 3);\n    std::vector<int> out(n);\n\n    // Extract every third element\n    for (int i = 0; i < third.size(); ++i) {\n        third[i] = l[i * 3];\n    }\n\n    // Sort the third array\n    sort_array(third);\n\n    // Reconstruct the output array\n    for (int i = 0; i < n; ++i) {\n        if ((i % 3) == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n    \n    return out;\n}\n\n// Function to check if two arrays are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Function to run test cases\nvoid run_tests() {\n    assert(issame(sort_third({1, 2, 3}), sort_third({1, 2, 3})));\n    assert(issame(sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10}), \n                  sort_third({5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10})));\n    assert(issame(sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10}), \n                  sort_third({5, 8, -12, 4, 23, 2, 3, 11, 12, -10})));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2}), \n                  std::vector<int>{2, 6, 3, 4, 8, 9, 5}));\n    assert(issame(sort_third({5, 8, 3, 4, 6, 9, 2}), \n                  std::vector<int>{2, 8, 3, 4, 6, 9, 5}));\n    assert(issame(sort_third({5, 6, 9, 4, 8, 3, 2}),\n                  std::vector<int>{2, 6, 9, 4, 8, 3, 5}));\n    assert(issame(sort_third({5, 6, 3, 4, 8, 9, 2, 1}), \n                  std::vector<int>{2, 6, 3, 4, 8, 9, 5, 1}));\n}\n\nint main() {\n    run_tests();\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code replicates the functionality of your provided Fortran program. It leverages the Standard Template Library (STL) for convenient vector manipulations and sorting. The `assert` function is used for testing conditions, similar to the Fortran code's custom `assert` subroutine.
Here's a translation of the provided Fortran code to C++. Note that the C++ version involves using the standard library functionalities like `std::vector` and algorithms from `<algorithm>` for performing tasks like sorting and checking for uniqueness.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Function to remove duplicates and sort the resulting array\nvoid unique(const std::vector<int>& input, std::vector<int>& output) {\n    std::vector<int> temp;\n    \n    // Remove duplicates\n    for (const auto& item : input) {\n        if (std::find(temp.begin(), temp.end(), item) == temp.end()) {\n            temp.push_back(item);\n        }\n    }\n    \n    // Sort the array\n    std::sort(temp.begin(), temp.end());\n    \n    // Assign to the output array\n    output = std::move(temp);\n}\n\n// Function to check if two arrays are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    return a == b;\n}\n\nint main() {\n    // Input array\n    std::vector<int> input = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    // Expected result\n    std::vector<int> expected = {0, 2, 3, 5, 9, 123};\n    // Result array\n    std::vector<int> result;\n    \n    // Call the unique function\n    unique(input, result);\n    \n    // Check if the result is the same as expected\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: result is not as expected" << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}\n```\n\nHere are a few notes on the translation:\n1. **Vectors**: C++ `std::vector` is used as it provides dynamic array functionalities similar to Fortran's allocatable arrays.\n2. **Unique Function**:\n    - **Duplicates Removal**: We use `std::find` to check for duplicates while iterating through the input vector.\n    - **Sorting**: `std::sort` from the `<algorithm>` library is used to sort the result.\n3. **Comparison Function**: The `issame` function uses `std::vector`'s equality operator to check if the two vectors are the same.\n4. **Error Handling**: `std::cerr` is used to print the error message if the assertion fails.\n\nThis C++ version is designed to mimic the behavior of the original Fortran code with modern C++ practices.
Here's the translated Fortran code to C++:\n\nFortran Code:\n```fortran\nmodule max_module\n  implicit none\ncontains\n  function max_element(arr) result(max_val)\n    implicit none\n    real, dimension(:), intent(in) :: arr\n    real :: max_val\n    integer :: i\n\n    max_val = -10000.0\n    do i = 1, size(arr)\n      if (max_val < arr(i)) max_val = arr(i)\n    end do\n  end function max_element\nend module max_module\n\nprogram main\n  use max_module\n  implicit none\n  real :: result\n  real, dimension(:), allocatable :: arr\n\n  ! Test case 1\n  if (allocated(arr)) deallocate(arr)\n  allocate(arr(3))\n  arr = [1.0, 2.0, 3.0]\n  result = max_element(arr)\n  if (abs(result - 3.0) > 1e-4) then\n    write(*,*) "Test case 1: assertion failed"\n    call exit(1)\n  end if\n\n  ! Test case 2\n  if (allocated(arr)) deallocate(arr)\n  allocate(arr(11))\n  arr = [5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 124.0, 1.0, -10.0]\n  result = max_element(arr)\n  if (abs(result - 124.0) > 1e-4) then\n    write(*,*) "Test case 2: assertion failed"\n    call exit(1)\n  end if\n\n  write(*,*) "All tests passed"\n  if (allocated(arr)) deallocate(arr)\nend program main\n```\n\nC++ Translation:\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstdlib>\n\nfloat max_element(const std::vector<float>& arr) {\n    float max_val = -10000.0f;\n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (max_val < arr[i]) {\n            max_val = arr[i];\n        }\n    }\n    return max_val;\n}\n\nint main() {\n    std::vector<float> arr;\n    float result;\n\n    // Test case 1\n    arr = {1.0f, 2.0f, 3.0f};\n    result = max_element(arr);\n    if (std::fabs(result - 3.0f) > 1e-4) {\n        std::cout << "Test case 1: assertion failed" << std::endl;\n        return 1;\n    } else {\n        std::cout << "Test case 1: passed" << std::endl;\n    }\n\n    // Test case 2\n    arr = {5.0f, 3.0f, -5.0f, 2.0f, -3.0f, 3.0f, 9.0f, 0.0f, 124.0f, 1.0f, -10.0f};\n    result = max_element(arr);\n    if (std::fabs(result - 124.0f) > 1e-4) {\n        std::cout << "Test case 2: assertion failed" << std::endl;\n        return 1;\n    } else {\n        std::cout << "Test case 2: passed" << std::endl;\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function `max_element`**:\n   - In Fortran, `max_element` is a function in a module that takes a real array and returns the max value.\n   - In C++, `max_element` is a function that takes a `std::vector<float>` and returns a `float`.\n\n2. **Main Program**:\n   - In Fortran, the main program uses dynamic arrays with allocation and deallocation.\n   - In C++, `std::vector` is used, which handles its own memory management.\n   \n3. **Test Cases**:\n   - Both test cases are replicated in C++ to ensure similar validation steps.\n   - For checking if values are close enough, `std::fabs` is used.\n   \n4. **Assertions**:\n   - If assertions fail in C++, the program outputs "assertion failed" and returns `1`.\n\nThis conversion maintains the structure and functionality of the original Fortran code.
Certainly! Here's the translated Fortran code in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // For exit function\n\nint fizz_buzz(int n);\nvoid assert_cond(bool condition, const std::string &message);\n\nint main() {\n    int result;\n\n    // Main program logic\n    result = fizz_buzz(50);\n    assert_cond(result == 0, "fizz_buzz(50) == 0: assertion failed");\n\n    result = fizz_buzz(78);\n    assert_cond(result == 2, "fizz_buzz(78) == 2: assertion failed");\n\n    result = fizz_buzz(79);\n    assert_cond(result == 3, "fizz_buzz(79) == 3: assertion failed");\n\n    result = fizz_buzz(100);\n    assert_cond(result == 3, "fizz_buzz(100) == 3: assertion failed");\n\n    result = fizz_buzz(200);\n    assert_cond(result == 6, "fizz_buzz(200) == 6: assertion failed");\n\n    result = fizz_buzz(4000);\n    assert_cond(result == 192, "fizz_buzz(4000) == 192: assertion failed");\n\n    result = fizz_buzz(10000);\n    assert_cond(result == 639, "fizz_buzz(10000) == 639: assertion failed");\n\n    result = fizz_buzz(100000);\n    assert_cond(result == 8026, "fizz_buzz(100000) == 8026: assertion failed");\n\n    return 0;\n}\n\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count++;\n                q /= 10;\n            }\n        }\n    }\n    return count;\n}\n\nvoid assert_cond(bool condition, const std::string &message) {\n    if (!condition) {\n        std::cout << message << std::endl;\n        std::exit(1);\n    }\n}\n```\n\nExplanation:\n- The Fortran `program` is mapped to the `main()` function in C++.\n- The `fizz_buzz` function is translated directly, retaining its logic, and is declared/prototyped before `main()`.\n- The Fortran `assert` subroutine is replaced with the `assert_cond` function in C++.\n- `assert_cond` prints the message and exits the program if the condition is `false`.\n\nThe translated C++ program should work similarly to the Fortran code, checking various test cases with `fizz_buzz` function and ensuring that the results are as expected.
Below is an equivalent C++ translation of the provided Fortran code. The code implements functions to sort even-indexed elements of an array and includes test cases to verify functionality.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\nbool issame(const std::vector<float>& a, const std::vector<float>& b, float tolerance = 1e-4) {\n    if (a.size() != b.size()) return false;\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (std::fabs(a[i] - b[i]) > tolerance) return false;\n    }\n\n    return true;\n}\n\nvoid sort_array(std::vector<float>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nstd::vector<float> sort_even(const std::vector<float>& l) {\n    size_t n = l.size();\n    std::vector<float> out(n);\n    std::vector<float> even((n + 1) / 2);\n\n    // Extract even-indexed elements\n    for (size_t i = 0; i < (n + 1) / 2; ++i) {\n        even[i] = l[2 * i];\n    }\n\n    // Sort the even-indexed elements\n    sort_array(even);\n\n    // Merge sorted even-indexed elements back into the output array\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    return out;\n}\n\nvoid run_tests() {\n    std::vector<float> l;\n    std::vector<float> result;\n    std::vector<float> expected;\n\n    // Test case 1\n    l = {1.0, 2.0, 3.0};\n    expected = {1.0, 2.0, 3.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {5.0, 3.0, -5.0, 2.0, -3.0, 3.0, 9.0, 0.0, 123.0, 1.0, -10.0};\n    expected = {-10.0, 3.0, -5.0, 2.0, -3.0, 3.0, 5.0, 0.0, 9.0, 1.0, 123.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {5.0, 8.0, -12.0, 4.0, 23.0, 2.0, 3.0, 11.0, 12.0, -10.0};\n    expected = {-12.0, 8.0, 3.0, 4.0, 5.0, 2.0, 12.0, 11.0, 23.0, -10.0};\n    result = sort_even(l);\n    if (!issame(result, expected)) {\n        std::cerr << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Explanation of the C++ Code:\n\n1. **Function `issame`:** \n    - Checks if two vectors are the same within a given tolerance.\n    \n2. **Function `sort_array`:** \n    - Sorts a vector using the standard library's `std::sort` function.\n    \n3. **Function `sort_even`:**\n    - Extracts even-indexed elements from the input vector.\n    - Sorts these elements.\n    - Merges the sorted even elements back into their original positions.\n    \n4. **Function `run_tests`:**\n    - Contains three test cases to verify the functionality of `sort_even`.\n    - Reports if any test case fails and exits the program.\n\nFinally, `main()` calls `run_tests` to perform the tests when the program is run.
To translate the given Fortran code to C++, we will create a similar structure using standard C++ constructs. The assertions will be implemented using the `assert` macro from the `<cassert>` header, and we will define the `car_race_collision` function separately. Below is the translated C++ code:\n\n```cpp\n#include <iostream>\n#include <cassert>\n\n// Function definition\nint car_race_collision(int n) {\n    return n * n;\n}\n\nint main() {\n    // Assertions\n    if (car_race_collision(2) != 4) {\n        std::cerr << "Assertion failed: car_race_collision(2) == 4" << std::endl;\n        return 1;\n    }\n\n    if (car_race_collision(3) != 9) {\n        std::cerr << "Assertion failed: car_race_collision(3) == 9" << std::endl;\n        return 1;\n    }\n\n    if (car_race_collision(4) != 16) {\n        std::cerr << "Assertion failed: car_race_collision(4) == 16" << std::endl;\n        return 1;\n    }\n\n    if (car_race_collision(8) != 64) {\n        std::cerr << "Assertion failed: car_race_collision(8) == 64" << std::endl;\n        return 1;\n    }\n\n    if (car_race_collision(10) != 100) {\n        std::cerr << "Assertion failed: car_race_collision(10) == 100" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Include Headers**: We include necessary headers for input-output operations (`<iostream>`) and assertions (`<cassert>`).\n   \n2. **Function Definition**: The function `car_race_collision` is defined to take an integer parameter `n` and return `n * n`.\n\n3. **Main Function**: \n   - In the `main` function, we use `assert` statements (or alternatively `if` statements followed by error outputs) to check the conditions given in the original Fortran code.\n   - If any condition fails, an error message is printed to the standard error stream using `std::cerr` and the program exits with a status code `1`.\n\nThis C++ code achieves the same functionality as the original Fortran code by performing the same checks and calculations.
Translating Fortran code to C++ requires converting constructs and memory management peculiarities of Fortran to their C++ equivalents:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n#include <numeric>\n\n// Function to increment each element of the list by 1\nstd::vector<int> incr_list(const std::vector<int>& l) {\n    std::vector<int> res(l.size());\n    std::transform(l.begin(), l.end(), res.begin(), [](int val) { return val + 1; });\n    return res;\n}\n\n// Function to check if two vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    return std::equal(a.begin(), a.end(), b.begin());\n}\n\nint main() {\n    std::vector<int> l;\n    std::vector<int> result;\n    std::vector<int> expected;\n    bool condition;\n\n    // Test case 1\n    l.clear();\n    result = incr_list(l);\n    expected.clear();\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cout << "Test case 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {3, 2, 1};\n    result = incr_list(l);\n    expected = {4, 3, 2};\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cout << "Test case 2: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    result = incr_list(l);\n    expected = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    condition = issame(result, expected);\n    if (!condition) {\n        std::cout << "Test case 3: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n    std::exit(0);\n\n    return 0;\n}\n```\n\nThis C++ program mirrors the structure and functionality of the Fortran program:\n- It uses the `std::vector` container from the C++ Standard Library to handle dynamic arrays.\n- Functions `incr_list` and `issame` perform the same operations as in the Fortran code.\n- The main function runs through the specified test cases, checking the results and managing program flow similarly.
Here's the translated Fortran code to C++:\n\n```c++\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nbool pairs_sum_to_zero(const std::vector<int>& l) {\n    for (size_t i = 0; i < l.size(); ++i) {\n        for (size_t j = i + 1; j < l.size(); ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> l;\n    bool result;\n\n    // Test case 1\n    l = {1, 3, 5, 0};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    l = {1, 3, -2, 1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    l = {1, 2, 3, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    l = {2, 4, -5, 3, 5, 7};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    l = {1};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    l = {-3, 9, -1, 3, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 7\n    l = {-3, 9, -1, 3, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != true) {\n        std::cout << "Test case 7 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 8\n    l = {-3, 9, -1, 4, 2, 30};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 8 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 9\n    l = {-3, 9, -1, 4, 2, 31};\n    result = pairs_sum_to_zero(l);\n    if (result != false) {\n        std::cout << "Test case 9 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nIn this conversion:\n\n1. The Fortran dynamic array `l` is replaced with a `std::vector<int>` in C++.\n2. The `allocate` and `deallocate` statements are not necessary in C++, as `std::vector` manages memory automatically.\n3. The `pairs_sum_to_zero` function is directly translated into a C++ function taking a `std::vector<int>` as a parameter.\n4. Logical operations (`.true.`, `.false.`) and comparisons (`.neqv.`) are replaced with their C++ equivalents (`true`, `false`, `!=`).
Here is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n// Function to change base\nstd::string change_base(int x, int base) {\n    std::string out;\n    int temp_x = x;\n\n    while (temp_x > 0) {\n        int remainder = temp_x % base;\n        out = std::to_string(remainder) + out;\n        temp_x /= base;\n    }\n\n    return out;\n}\n\n// Integer to string conversion function\nstd::string itoa(int num) {\n    return std::to_string(num);\n}\n\nvoid assert_equal(const std::string& result, const std::string& expected, const std::string& message) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << message << " == '" << expected << "'\n";\n        exit(1);\n    }\n}\n\nint main() {\n    // Assertions\n    assert_equal(change_base(8, 3), "22", "change_base(8, 3)");\n    assert_equal(change_base(9, 3), "100", "change_base(9, 3)");\n    assert_equal(change_base(234, 2), "11101010", "change_base(234, 2)");\n    assert_equal(change_base(16, 2), "10000", "change_base(16, 2)");\n    assert_equal(change_base(8, 2), "1000", "change_base(8, 2)");\n    assert_equal(change_base(7, 2), "111", "change_base(7, 2)");\n\n    for (int x = 2; x <= 7; ++x) {\n        assert_equal(change_base(x, x + 1), itoa(x), "change_base(" + std::to_string(x) + ", " + std::to_string(x + 1) + ")");\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Functions Conversion**:\n   - The `change_base` function translates the logic of converting a number from one base to another. This function constructs the result by repeatedly dividing the number by the new base and collecting remainders.\n   - The `itoa` function in C++ uses `std::to_string` which converts an integer to a string.\n\n2. **Assertions**:\n   - I've added an `assert_equal` helper function that checks whether the result matches the expected value. If not, it prints an error message and exits with a non-zero status.\n\n3. **Const Strings**:\n   - The Fortran program uses `character(len=100)` to define string length. In C++, `std::string` dynamically handles lengths, so direct usage of `std::string` is more appropriate.\n\n4. **`main` Function**:\n   - This function includes assertions to ensure the `change_base` function works correctly. The assertions use `assert_equal` to compare the results against the expected values and report any discrepancies.\n\nThis C++ code maintains the same logic and functionality as the Fortran program.
Here is the equivalent C++ code for your Fortran program:\n\n```cpp\n#include <iostream>\n#include <cmath> // For std::fabs\n#include <cstdlib> // For std::exit\n\ndouble triangle_area(double a, double h) {\n    return (a * h) * 0.5;\n}\n\nint main() {\n    double result;\n\n    // Test cases\n    result = triangle_area(5.0, 3.0);\n    if (std::fabs(result - 7.5) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(5, 3) should be 7.5" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(2.0, 2.0);\n    if (std::fabs(result - 2.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(2, 2) should be 2.0" << std::endl;\n        std::exit(1);\n    }\n\n    result = triangle_area(10.0, 8.0);\n    if (std::fabs(result - 40.0) > 1e-4) {\n        std::cerr << "Assertion failed: triangle_area(10, 8) should be 40.0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code does the same as your Fortran code:\n- It defines a function `triangle_area` to calculate the area of a triangle given the base `a` and height `h`.\n- It performs the same three test cases and checks if the calculated area is within a tolerance of `1e-4` from the expected value.\n- It prints a message and exits with an error code if any test fails.\n- If all tests pass, it outputs a success message.
Here's the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nint fib4(int n) {\n    int f[100] = {0};\n    \n    // Initialize the first four elements\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n\n    // Compute the sequence\n    for (int i = 4; i <= n; ++i) {\n        f[i] = f[i-1] + f[i-2] + f[i-3] + f[i-4];\n    }\n\n    return f[n];\n}\n\nint main() {\n    // Assertions\n    if (fib4(5) != 4) {\n        std::cerr << "fib4(5) == 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    if (fib4(8) != 28) {\n        std::cerr << "fib4(8) == 28: assertion failed" << std::endl;\n        return 1;\n    }\n\n    if (fib4(10) != 104) {\n        std::cerr << "fib4(10) == 104: assertion failed" << std::endl;\n        return 1;\n    }\n\n    if (fib4(12) != 386) {\n        std::cerr << "fib4(12) == 386: assertion failed" << std::endl;\n        return 1;\n    }\n\n    // If all assertions pass\n    std::cout << "All assertions passed successfully!" << std::endl;\n    return 0;\n}\n```\n\nExplanation:\n1. The `fib4` function in C++ performs the same operations as the Fortran `fib4` function, initializing an array `f` with the required values and then computing the sequence using the same logic.\n2. The `main` function in C++ includes the equivalent assertions using `std::cerr` for error messages and `return 1` to exit the program if an assertion fails.\n3. If all assertions pass, the program prints a success message and exits with `return 0`.
Sure! Here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n\n// Sort the array in place using simple bubble sort\nvoid sort(std::vector<float>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[i] > arr[j]) {\n                std::swap(arr[i], arr[j]);\n            }\n        }\n    }\n}\n\n// Function to calculate the median of an array\nfloat median(const std::vector<float>& arr) {\n    std::vector<float> sorted_arr = arr;\n    sort(sorted_arr);\n    int n = sorted_arr.size();\n\n    if (n % 2 == 1) {\n        return sorted_arr[(n + 1) / 2 - 1];\n    } else {\n        return 0.5 * (sorted_arr[n / 2 - 1] + sorted_arr[n / 2]);\n    }\n}\n\nvoid test_median() {\n    // Test case 1\n    if (std::fabs(median({3.0f, 1.0f, 2.0f, 4.0f, 5.0f}) - 3.0f) > 1e-4) {\n        std::cerr << "Test case 1 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    if (std::fabs(median({-10.0f, 4.0f, 6.0f, 1000.0f, 10.0f, 20.0f}) - 8.0f) > 1e-4) {\n        std::cerr << "Test case 2 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    if (std::fabs(median({5.0f}) - 5.0f) > 1e-4) {\n        std::cerr << "Test case 3 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    if (std::fabs(median({6.0f, 5.0f}) - 5.5f) > 1e-4) {\n        std::cerr << "Test case 4 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    if (std::fabs(median({8.0f, 1.0f, 3.0f, 9.0f, 9.0f, 2.0f, 7.0f}) - 7.0f) > 1e-4) {\n        std::cerr << "Test case 5 failed: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed." << std::endl;\n}\n\nint main() {\n    test_median();\n    return 0;\n}\n```\n\nExplanation:\n1. The `sort` function uses a simple bubble sort algorithm to sort the input vector `arr` in ascending order.\n2. The `median` function calculates the median of the given vector `arr`. It first creates a copy of the input vector, sorts it, and then calculates the median value based on whether the size of the vector is odd or even.\n3. The `test_median` function runs multiple test cases to verify the correctness of the `median` function. If any test case fails, it prints an error message and exits the program.\n4. The `main` function simply calls the `test_median` function to execute the tests.
Here's a C++ translation of the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(const std::string& text) {\n    std::string reversed_text = text;\n    std::reverse(reversed_text.begin(), reversed_text.end());\n    return text == reversed_text;\n}\n\nint main() {\n    if (!is_palindrome("")) {\n        std::cerr << "Assertion failed: is_palindrome('') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aba")) {\n        std::cerr << "Assertion failed: is_palindrome('aba') == true" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("aaaaa")) {\n        std::cerr << "Assertion failed: is_palindrome('aaaaa') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("zbcd")) {\n        std::cerr << "Assertion failed: is_palindrome('zbcd') == false" << std::endl;\n        return 1;\n    }\n\n    if (!is_palindrome("xywyx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyx') == true" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywyz")) {\n        std::cerr << "Assertion failed: is_palindrome('xywyz') == false" << std::endl;\n        return 1;\n    }\n\n    if (is_palindrome("xywzx")) {\n        std::cerr << "Assertion failed: is_palindrome('xywzx') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definition**: The `is_palindrome` function takes a `const std::string&` as input and returns a `bool`. It creates a reversed copy of the input string and checks if it matches the original.\n\n2. **Main Function**: The `main` function performs the same set of assertions as the Fortran program. Instead of using `write` and `exit`, it uses `std::cerr` to print error messages and `return 1` to indicate failure.\n\n3. **String Reversal**: Uses C++'s `<algorithm>` library to reverse the string efficiently.\n\nThis C++ code should behave identically to the original Fortran code, checking if various strings are palindromes and outputting relevant messages if any assertion fails. If all tests pass, it prints "All tests passed."
Sure! Here's the corresponding C++ code translated from the Fortran code you provided:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\n// Function definition\nint modp(int n, int p) {\n    int modp = 1;\n    for (int i = 1; i <= n; ++i) {\n        modp = (modp * 2) % p;\n    }\n    return modp;\n}\n\nint main() {\n    int result;\n\n    // Assertions\n    result = modp(3, 5);\n    if (result != 3) {\n        std::cerr << "modp(3, 5) == 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(1101, 101);\n    if (result != 2) {\n        std::cerr << "modp(1101, 101) == 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(0, 101);\n    if (result != 1) {\n        std::cerr << "modp(0, 101) == 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(3, 11);\n    if (result != 8) {\n        std::cerr << "modp(3, 11) == 8: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(100, 101);\n    if (result != 1) {\n        std::cerr << "modp(100, 101) == 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(30, 5);\n    if (result != 4) {\n        std::cerr << "modp(30, 5) == 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    result = modp(31, 5);\n    if (result != 3) {\n        std::cerr << "modp(31, 5) == 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nExplanation:\n\n1. The Fortran `integer function modp(n, p)` is translated to a C++ function `int modp(int n, int p)`.\n2. The main Fortran program is translated to a `main` function in C++.\n3. The `do` loop in Fortran becomes a `for` loop in C++.\n4. The `write(*,*)` statements from Fortran are replaced with `std::cerr` for error messages and `std::cout` for the success message in C++ to match the respective use of standard error and standard output.\n5. The use of `call exit(1)` in Fortran is translated to `return 1` in C++ to exit the program with a status code of 1 upon an assertion failure.\n6. The variable declaration for `result` remains an integer.\n\nRemember to include the necessary headers in C++ (`#include <iostream>`, `#include <cstdlib>`). This code should be functionally equivalent to the provided Fortran code.
Below is the C++ equivalent of the provided Fortran code. The C++ version uses the `<string>`, `<random>`, and `<iostream>` libraries to implement the functionality:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <random>\n\nstd::string encode_shift(const std::string& s);\nstd::string decode_shift(const std::string& s);\n\nint main() {\n    std::mt19937 rng(std::random_device{}()); // use a random device as the seed for the random number generator\n    std::uniform_int_distribution<int> length_dist(10, 20);\n    std::uniform_int_distribution<int> char_dist(0, 25);\n\n    for (int i = 0; i < 100; ++i) {\n        int l = length_dist(rng);\n        std::string str;\n\n        for (int j = 0; j < l; ++j) {\n            char chr = 'a' + char_dist(rng);\n            str += chr;\n        }\n\n        std::string encoded_str = encode_shift(str);\n        std::string decoded_str = decode_shift(encoded_str);\n\n        if (decoded_str != str) {\n            std::cerr << "Assertion failed: decoded string does not match original" << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nstd::string encode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = ((s[i] - 'a' + 5) % 26) + 'a';\n        out[i] = c;\n    }\n    return out;\n}\n\nstd::string decode_shift(const std::string& s) {\n    std::string out = s;\n    for (size_t i = 0; i < s.length(); ++i) {\n        char c = ((s[i] - 'a' + 21) % 26) + 'a';\n        out[i] = c;\n    }\n    return out;\n}\n```\n\n### Explanation\n\n1. **Initialization and Random Number Generation**:\n    - We use `<random>` to handle random number generation which is seeded using `std::random_device`.\n    - The length of the string (`l`) is between 10 and 20 (inclusive for both).\n    - Each character is randomly selected from 'a' to 'z'.\n\n2. **Main Loop**:\n    - The loop runs 100 times to generate random strings, encode them, and then decode them.\n    - The string generation involves concatenating random characters from 'a' to 'z'.\n\n3. **Encode and Decode Functions**:\n    - `encode_shift` and `decode_shift` implement the character shifting. They add or subtract a specified shift amount (5 for encoding, 21 for decoding) using the modulo operation to wrap around the alphabet.\n\n4. **Assertion**:\n    - If the decoded string does not match the original string, an error is printed, and the program terminates with a non-zero exit code.\n\n### Additional Notes\n- The random number generation assumes uniform distribution for both lengths and characters.\n- The encode/decode functions directly manipulate string indices to shift the characters.\n- Error handling is done using `std::cerr` to print messages and returning a non-zero exit code to indicate failure.
Below is the translated code from Fortran to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\n// Function to remove vowels from a string\nstd::string remove_vowels(const std::string& text) {\n    std::string vowels = "AEIOUaeiou";\n    std::string result;\n    \n    for (char ch : text) {\n        // Check if the character is a vowel\n        if (vowels.find(ch) == std::string::npos) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    // Test cases\n    assert(remove_vowels("") == "");\n    assert(remove_vowels("abcdef//nghijklm") == "bcdf//nghjklm");\n    assert(remove_vowels("fedcba") == "fdcb");\n    assert(remove_vowels("eeeee") == "");\n    assert(remove_vowels("acBAA") == "cB");\n    assert(remove_vowels("EcBOO") == "cB");\n    assert(remove_vowels("ybcd") == "ybcd");\n\n    std::cout << "All assertions passed!" << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation of Changes:\n\n1. **Function Definition**: The Fortran `remove_vowels` function is translated into a C++ function. The function signature in C++ uses `std::string` for dynamic strings, which fits well with C++ idioms.\n   \n2. **Main Program**: The `main` function in C++ sets up test cases using `assert` to ensure the behavior matches the specifications.\n   \n3. **Looping and Conditional Checking**: The nested loop in Fortran to check for vowels is translated to C++ using a more idiomatic approach with a single loop and the `std::string::find` method to determine if a character is a vowel.\n   \n4. **String Concatenation**: In Fortran, string concatenation is done with the `//` operator. In C++, we use the `+=` operator to append characters to a string.\n\n5. **Assertions**: Fortran uses a subroutine to handle assertions, whereas C++ uses the `assert` macro from the `<cassert>` library to test conditions and halt execution if they are not met.\n\n6. **Printing to Console**: The C++ code uses `std::cout` to output a success message after all assertions pass, indicating that the tests were successful.
Here's the translated C++ code that matches the functionality of the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nbool below_threshold(const std::vector<int>& l, int t) {\n    for (int i = 0; i < l.size(); ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> l;\n    int t;\n\n    // Test case 1\n    l = {1, 2, 4, 10};\n    t = 100;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 2, 4, 10}, 100)" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 2\n    l = {1, 20, 4, 10};\n    t = 5;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 20, 4, 10}, 5))" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 3\n    l = {1, 20, 4, 10};\n    t = 21;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 21)" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 4\n    l = {1, 20, 4, 10};\n    t = 22;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 20, 4, 10}, 22)" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 5\n    l = {1, 8, 4, 10};\n    t = 11;\n    if (!below_threshold(l, t)) {\n        std::cerr << "Assertion failed: below_threshold({1, 8, 4, 10}, 11)" << std::endl;\n        std::exit(1);\n    }\n\n    // Test case 6\n    l = {1, 8, 4, 10};\n    t = 10;\n    if (below_threshold(l, t)) {\n        std::cerr << "Assertion failed: not(below_threshold({1, 8, 4, 10}, 10))" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function `below_threshold`**:\n   - This function checks if all elements in the given vector `l` are below the threshold `t`. It iterates through the vector, and if it finds any element that is greater than or equal to `t`, it returns `false`. If all elements are below `t`, it returns `true`, mimicking the logic in the original Fortran function.\n\n2. **Main Function**:\n   - Similar to the Fortran code, the main function contains several test cases, where the vector `l` and the threshold `t` are defined, and the `below_threshold` function is tested.\n   - If any assertion fails (i.e., the result of `below_threshold` doesn't match the expected result), an error message is printed to `stderr`, and the program exits with a status of 1.\n   - The assertions ensure that the `below_threshold` function behaves as expected for different inputs.\n\n### Note:\n- In C++, vectors from the Standard Library (STL) are used to handle dynamic arrays.\n- The `std::vector<int>` type is equivalent to the dynamically allocated array `integer, dimension(:), allocatable :: l` in Fortran.\n- Standard IO (`std::cerr` and `std::exit`) is used to handle output and program termination similar to the `write` and `call exit` in Fortran.
Sure, I'll translate the provided Fortran code to C++.\n\nThe following C++ code retains the structure and functionality of the original Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n\n// Function to add two integers\nint add(int x, int y) {\n    return x + y;\n}\n\nint main() {\n    int x, y;\n    float rand_val;\n\n    // Initialize random number generator\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n    // Assertions\n    assert(add(0, 1) == 1 && "Assertion failed: add(0, 1) == 1");\n    assert(add(1, 0) == 1 && "Assertion failed: add(1, 0) == 1");\n    assert(add(2, 3) == 5 && "Assertion failed: add(2, 3) == 5");\n    assert(add(5, 7) == 12 && "Assertion failed: add(5, 7) == 12");\n    assert(add(7, 5) == 12 && "Assertion failed: add(7, 5) == 12");\n\n    // Loop with random number generation and assertions\n    for (int i = 0; i < 100; ++i) {\n        rand_val = static_cast<float>(std::rand()) / RAND_MAX;\n        x = static_cast<int>(rand_val * 1000);\n        rand_val = static_cast<float>(std::rand()) / RAND_MAX;\n        y = static_cast<int>(rand_val * 1000);\n        assert(add(x, y) == x + y && "Assertion failed: add(x, y) == x + y");\n    }\n\n    std::cout << "All assertions passed successfully!" << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Random Number Generation**:\n   - In C++, `std::rand()` generates a random number. To convert it to a float between 0 and 1, divide by `RAND_MAX`.\n\n2. **Assertions**:\n   - Use `assert` for assertions. The `assert` macro will terminate the program if the condition evaluates to false. The added string is a custom error message that will be printed when an assertion fails.\n\n3. **Loop**:\n   - A `for` loop iterates 100 times, generating random values for `x` and `y` within the range [0, 1000).\n\n4. **Random Number Initialization**:\n   - `std::srand` is used to seed the random number generator with the current time.\n\n5. **Function Definition**:\n   - The `add` function is defined outside the `main` function and adds two integers.\n\n### Differences from Fortran:\n\n- Fortran uses the `random_number` subroutine for generating random numbers, whereas C++ uses `std::rand`.\n- Fortran's `implicit none` ensures all variables must be explicitly declared. This isn't necessary in C++ because all variables must be declared.\n- Fortran's `write` statement is similar to `std::cout` in C++.\n- Fortran's `call exit(1)` is equivalent to C++'s `std::exit(1)`.\n\nBy following these translations, the C++ code retains the logic and structure of the original Fortran code.
Sure, here is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Function declaration\nbool same_chars(const std::string& s0, const std::string& s1);\n\nint main() {\n    bool result;\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddeddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddeddabc') == true" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("abcd", "dddddddabc");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabc') == true" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("dddddddabc", "abcd");\n    if (!result) {\n        std::cerr << "Assertion failed: same_chars('dddddddabc', 'abcd') == true" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("eabcd", "dddddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcd', 'dddddddabc') == false" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("abcd", "dddddddabcf");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('abcd', 'dddddddabcf') == false" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("eabcdzzzz", "dddzzzzzzzddddabc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('eabcdzzzz', 'dddzzzzzzzddddabc') == false" << std::endl;\n        return 1;\n    }\n\n    result = same_chars("aabb", "aaccc");\n    if (result) {\n        std::cerr << "Assertion failed: same_chars('aabb', 'aaccc') == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n\nbool same_chars(const std::string& s0, const std::string& s1) {\n    // Check if every character in s0 is in s1\n    for (char ch : s0) {\n        if (s1.find(ch) == std::string::npos) {\n            return false;\n        }\n    }\n\n    // Check if every character in s1 is in s0\n    for (char ch : s1) {\n        if (s0.find(ch) == std::string::npos) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n### Explanation:\n\n1. **Function Declaration**: The function `same_chars` is declared to take two `const std::string&` arguments and return a `bool`.\n\n2. **Main Function**: The `main` function performs a series of tests using `same_chars`, similar to the Fortran test cases, and outputs respective error messages if the assertions fail.\n\n3. **same_chars Function**: \n   - The function loops through each character of `s0` and checks if it's present in `s1`. If any character is not found, the function returns `false`.\n   - Then, it checks each character of `s1` to see if it's present in `s0`. If any character is not found, the function returns `false`.\n   - If all characters are found in both strings, the function returns `true`.\n\nThis C++ program mimics the logic of the given Fortran program closely while utilizing C++ standard library functions and constructs.
Here is the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint fib(int n) {\n    std::vector<int> f(n + 2); // Create vector with n+2 elements\n    f[1] = 0;\n    f[2] = 1;\n    for (int i = 3; i <= n + 1; ++i) {\n        f[i] = f[i - 1] + f[i - 2];\n    }\n    return f[n + 1];\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = fib(10);\n    if (result != 55) {\n        std::cerr << "fib(10) == 55: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(1);\n    if (result != 1) {\n        std::cerr << "fib(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(8);\n    if (result != 21) {\n        std::cerr << "fib(8) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(11);\n    if (result != 89) {\n        std::cerr << "fib(11) == 89: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = fib(12);\n    if (result != 144) {\n        std::cerr << "fib(12) == 144: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code achieves the same functionality as the Fortran code by:\n\n1. Using a `vector<int>` to dynamically allocate memory for the Fibonacci sequence array `f`.\n2. Implementing the Fibonacci calculation similarly but using C++ syntax.\n3. Handling assertions and output using `std::cerr` and `std::cout` for error messages and standard output, respectively.\n4. Using `std::exit(1)` to terminate the program with an error code if an assertion fails.
Here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n// Function to check if the array is monotonic\nbool is_monotonic(const std::vector<float>& l) {\n    if (l.size() < 2) {\n        return true;\n    }\n\n    bool incr = false;\n    bool decr = false;\n\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > l[i - 1]) incr = true;\n        if (l[i] < l[i - 1]) decr = true;\n    }\n\n    return !(incr && decr);\n}\n\nint main() {\n    std::vector<std::vector<float>> test_cases = {\n        {1.0, 2.0, 4.0, 10.0},\n        {1.0, 2.0, 4.0, 20.0},\n        {1.0, 20.0, 4.0, 10.0},\n        {4.0, 1.0, 0.0, -10.0},\n        {4.0, 1.0, 1.0, 0.0},\n        {1.0, 2.0, 3.0, 2.0, 5.0, 60.0},\n        {1.0, 2.0, 3.0, 4.0, 5.0, 60.0},\n        {9.0, 9.0, 9.0, 9.0}\n    };\n\n    std::vector<bool> expected_results = {\n        true, true, false, true, true, false, true, true\n    };\n\n    for (size_t i = 0; i < test_cases.size(); ++i) {\n        if (is_monotonic(test_cases[i]) != expected_results[i]) {\n            std::cerr << "Assertion failed for test case " << i + 1 << std::endl;\n            std::exit(1);\n        }\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\nExplanation of changes:\n\n1. **Fortran Module to C++ Function**: The Fortran `module` and `function` have been converted to a C++ function called `is_monotonic`.\n2. **Arrays to std::vector**: Fortran uses arrays, whereas in C++, `std::vector` is used for dynamic array-like structures.\n3. **Looping and Conditional Statements**: The Fortran `do` loop and conditionals were converted directly to C++ `for` loops and `if` statements.\n4. **Test Cases**: The Fortran test cases were set up using dynamic array allocation and initialization. In C++, this was done using `std::vector` with initializer lists.\n5. **Error Handling and Assertions**: Fortran uses `write` for output and `call exit` for terminating the program. In C++, `std::cerr` and `std::exit` were used instead.\n\nThis C++ program performs the same functionality as the original Fortran code and ensures that all test cases are checked for monotonicity.
Certainly! Here is the equivalent C++ code for the provided Fortran module and program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid sort(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\nvoid common(const std::vector<int>& l1, const std::vector<int>& l2, std::vector<int>& out) {\n    std::vector<int> temp;\n    for (int i = 0; i < l1.size(); ++i) {\n        bool found = false;\n        for (int j = 0; j < temp.size(); ++j) {\n            if (temp[j] == l1[i]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            if (std::find(l2.begin(), l2.end(), l1[i]) != l2.end()) {\n                temp.push_back(l1[i]);\n            }\n        }\n    }\n\n    if (!temp.empty()) {\n        sort(temp);\n        out = temp;\n    } else {\n        out.clear();\n    }\n}\n\nint main() {\n    std::vector<int> l1, l2, result, expected;\n    bool is_same;\n\n    // Test case 1\n    l1 = {1, 4, 3, 34, 653, 2, 5};\n    l2 = {5, 7, 1, 5, 9, 653, 121};\n    expected = {1, 5, 653};\n    common(l1, l2, result);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    l1 = {5, 3, 2, 8};\n    l2 = {3, 2};\n    expected = {2, 3};\n    common(l1, l2, result);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    l1 = {4, 3, 2, 8};\n    l2 = {3, 2, 4};\n    expected = {2, 3, 4};\n    common(l1, l2, result);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    l1 = {4, 3, 2, 8};\n    l2.clear();\n    expected.clear();\n    common(l1, l2, result);\n    is_same = issame(result, expected);\n    if (!is_same) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function `issame`**: Checks if two vectors are identical by comparing their sizes and each corresponding element.\n2. **Function `sort`**: Uses `std::sort` from the C++ Standard Library to sort the vector.\n3. **Function `common`**: \n   - Finds common elements between `l1` and `l2` while ensuring each element in the result is unique.\n   - Temporary vector `temp` stores these unique elements.\n   - `std::find` is used to check if an element from `l1` is in `l2`.\n4. **Main Function**:\n   - Executes several test cases checking the functionality of the `common` function.\n   - Prints "All test cases passed" if all assertions hold. Otherwise, it indicates which test case failed.\n\nThis C++ code mirrors the logic of the original Fortran code using appropriate C++ constructs and features.
Here's the Fortran code translated into C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint largest_prime_factor(int n);\n\nint main() {\n    // Assertions\n    if (largest_prime_factor(15) != 5) {\n        std::cerr << "Assertion failed: largest_prime_factor(15) == 5" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(27) != 3) {\n        std::cerr << "Assertion failed: largest_prime_factor(27) == 3" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(63) != 7) {\n        std::cerr << "Assertion failed: largest_prime_factor(63) == 7" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(330) != 11) {\n        std::cerr << "Assertion failed: largest_prime_factor(330) == 11" << std::endl;\n        std::exit(1);\n    }\n\n    if (largest_prime_factor(13195) != 29) {\n        std::cerr << "Assertion failed: largest_prime_factor(13195) == 29" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n\nint largest_prime_factor(int n) {\n    int num = n;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        while (num % i == 0 && num > i) {\n            num /= i;\n        }\n    }\n    return num;\n}\n```\n\n### Explanation:\n\n1. **Header Inclusions**: The necessary headers `iostream`, `cmath`, and `cstdlib` are included for input/output operations, mathematical functions, and exit functions respectively.\n\n2. **Function Declaration**: The `largest_prime_factor` function is declared before the `main` function.\n\n3. **Assertions in `main`**: The assertions verify the correctness of the `largest_prime_factor` function by checking its return values for specific inputs. If an assertion fails, it outputs an error message and exits the program using `std::exit(1)`.\n\n4. **Function Definition**: The `largest_prime_factor` function calculates the largest prime factor of a given integer `n`, similar to the provided Fortran code.\n\nThis C++ code maintains the same functionality and structure as the original Fortran program.
Sure! Here's the equivalent C++ code for your Fortran program:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\n// Function definition\nint sum_to_n(int n) {\n    return n * (n + 1) / 2;\n}\n\nint main() {\n    // Assertions\n    if (sum_to_n(1) != 1) {\n        std::cerr << "sum_to_n(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(6) != 21) {\n        std::cerr << "sum_to_n(6) == 21: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(11) != 66) {\n        std::cerr << "sum_to_n(11) == 66: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(30) != 465) {\n        std::cerr << "sum_to_n(30) == 465: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (sum_to_n(100) != 5050) {\n        std::cerr << "sum_to_n(100) == 5050: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nThis C++ program implements the same logic as your provided Fortran code. The function `sum_to_n` is defined to compute the sum from 1 to `n` using the formula \( n \times (n + 1) / 2 \), and a series of assertions are made in the `main` function to check that this function works correctly for given values. If any assertion fails, an error message is printed and the program exits with a status code of 1.
Certainly! Here's the equivalent C++ code for the provided Fortran program. This code performs the same functionality:\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool correct_bracketing(const std::string &brackets) {\n    int level = 0;\n    for (char ch : brackets) {\n        if (ch == '(') {\n            level++;\n        } else if (ch == ')') {\n            level--;\n        }\n        if (level < 0) {\n            return false;\n        }\n    }\n    return level == 0;\n}\n\nvoid assert_bracketing(const std::string &brackets, bool expected) {\n    bool result = correct_bracketing(brackets);\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << brackets << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_bracketing("()", true);\n    assert_bracketing("(()())", true);\n    assert_bracketing("()()(()())()", true);\n    assert_bracketing("()()((()()())())(()()(()))", true);\n    assert_bracketing("((()())))", false);\n    assert_bracketing(")(()", false);\n    assert_bracketing("(", false);\n    assert_bracketing("((((", false);\n    assert_bracketing(")", false);\n    assert_bracketing("(()", false);\n    assert_bracketing("()()(()())())(()", false);\n    assert_bracketing("()()(()())()))()", false);\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nIn this C++ code:\n1. The `correct_bracketing` function is a direct translation of the Fortran `correct_bracketing` function.\n2. The `assert_bracketing` function is used to test the `correct_bracketing` function and check if it returns the expected result.\n3. `main` contains the test cases, similar to the Fortran program. If any test fails, it outputs an error message and terminates the program.\n4. If all tests pass, it prints "All tests passed." and exits normally.
Sure, hereâ€™s the C++ equivalent of your Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint fibfib(int n) {\n    if (n < 0) {\n        return -1;  // For invalid `n`, we return -1 (adjust logic as needed)\n    }\n    \n    std::vector<int> ff(n+1, 0); // Initialize vector of size n+1 with all zeros\n\n    // Initial values\n    ff[0] = 0;\n    ff[1] = 0;\n    ff[2] = 1;\n\n    // Compute the sequence\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i-1] + ff[i-2] + ff[i-3];\n    }\n\n    return ff[n];\n}\n\nint main() {\n    // Assertions\n    if (fibfib(2) != 1) {\n        std::cerr << "fibfib(2) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(1) != 0) {\n        std::cerr << "fibfib(1) == 0: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(5) != 4) {\n        std::cerr << "fibfib(5) == 4: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(8) != 24) {\n        std::cerr << "fibfib(8) == 24: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(10) != 81) {\n        std::cerr << "fibfib(10) == 81: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(12) != 274) {\n        std::cerr << "fibfib(12) == 274: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (fibfib(14) != 927) {\n        std::cerr << "fibfib(14) == 927: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `fibfib(int n)`**: This function computes the sequence similar to the Fortran version. It uses a `std::vector` to store intermediate values.\n2. **Assertions in `main`**: Instead of Fortran's `if` statements and `write` calls for assertions, we use C++'s error stream `std::cerr` and terminate the program using `std::exit(1)` in case of failed assertions.\n3. **Vector Initialization**: `std::vector<int> ff(n+1, 0);` initializes a vector of size `n+1` with all elements set to 0.\n4. **Compute Sequence**: The `for` loop calculates the sequence values similar to the `do` loop in Fortran.\n\nThis C++ program should emulate the behavior of the Fortran program closely.
Below is the C++ translation of the given Fortran code. The code includes similar logic and functionality, ensuring it's idiomatic in C++.\n\n```cpp\n#include <iostream>\n#include <string>\n\nint vowels_count(const std::string& s) {\n    std::string vowels = "aeiouAEIOU";\n    int count = 0;\n\n    for (char c : s) {\n        if (vowels.find(c) != std::string::npos) {\n            count++;\n        }\n    }\n\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n\n#define ASSERT_EQ(expected, actual, message) \\n    if (expected != actual) { \\n        std::cerr << "Assertion failed for '" << message << "'. Expected: " << expected << " but got: " << actual << std::endl; \\n        exit(1); \\n    }\n\nint main() {\n    // Test cases\n    ASSERT_EQ(2, vowels_count("abcde"), "abcde");\n    ASSERT_EQ(3, vowels_count("Alone"), "Alone");\n    ASSERT_EQ(2, vowels_count("key"), "key");\n    ASSERT_EQ(1, vowels_count("bye"), "bye");\n    ASSERT_EQ(2, vowels_count("keY"), "keY");\n    ASSERT_EQ(1, vowels_count("bYe"), "bYe");\n    ASSERT_EQ(3, vowels_count("ACEDY"), "ACEDY");\n    \n    std::cout << "All tests passed successfully." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **vowels_count Function**: \n    - This function counts the number of vowels in a given string, including the special rule where 'y' or 'Y' at the end of the string counts as a vowel.\n    - The loop iterates through each character in the string `s` and checks if it's a vowel by looking it up in the `vowels` string.\n    - If the last character is 'y' or 'Y', it additionally increments the count.\n\n2. **Main Function**:\n    - Multiple test cases are provided to validate the `vowels_count` function.\n    - `ASSERT_EQ` macro is used to check if the expected count matches the actual count.\n    - If a test case fails, the program prints an error message and exits.\n    - If all tests pass, it prints a success message.\n\nThis translation follows the structure and logic of the Fortran code but uses C++ libraries and idioms instead.
Certainly! Here's the translated C++ code for the Fortran program you provided:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib> // for exit\n\nstd::string reverse_string(const std::string& s) {\n    std::string reversed(s.rbegin(), s.rend());\n    return reversed;\n}\n\nstd::string circular_shift(int x, int shift) {\n    std::string xs = std::to_string(x);\n    std::string shifted;\n    int len_xs = xs.size();\n\n    if (len_xs < shift) {\n        shifted = reverse_string(xs);\n    } else {\n        int actual_shift = shift % len_xs;\n        shifted = xs.substr(len_xs - actual_shift) + xs.substr(0, len_xs - actual_shift);\n    }\n    return shifted;\n}\n\nint main() {\n    std::string result;\n\n    result = circular_shift(100, 2);\n    if (result != "001") {\n        std::cerr << "Assertion failed: circular_shift(100, 2) == '001'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 2);\n    if (result != "12") {\n        std::cerr << "Assertion failed: circular_shift(12, 2) == '12'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(97, 8);\n    if (result != "79") {\n        std::cerr << "Assertion failed: circular_shift(97, 8) == '79'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(12, 1);\n    if (result != "21") {\n        std::cerr << "Assertion failed: circular_shift(12, 1) == '21'" << std::endl;\n        std::exit(1);\n    }\n\n    result = circular_shift(11, 101);\n    if (result != "11") {\n        std::cerr << "Assertion failed: circular_shift(11, 101) == '11'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **reverse_string function**: This function takes a string as input and returns its reversed version using C++'s `std::string` facilities.\n2. **circular_shift function**: This function converts an integer `x` to a string, checks the length, and performs the circular shift as described. If the length of the number string is less than the shift amount, it reverses the string. Otherwise, it performs a circular shift using the `substr` method of the string class.\n3. **main function**: This function performs the tests as in the original Fortran program. It verifies the output of `circular_shift` for different inputs and prints the results.\n\nCompile and run this C++ code using a suitable C++ compiler like `g++`. Here is a command for compiling it using `g++`:\n```sh\ng++ -o circular_shift_test circular_shift_test.cpp\n./circular_shift_test\n```
Here is the translation of the provided Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\n// Function to calculate the digit sum\nint digitSum(const std::string &s) {\n    int sum = 0;\n    for (const char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n\nint main() {\n    // Assertions\n    if (digitSum("") != 0) {\n        std::cerr << "Assertion failed: digitSum('') == 0" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("abAB") != 131) {\n        std::cerr << "Assertion failed: digitSum('abAB') == 131" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("abcCd") != 67) {\n        std::cerr << "Assertion failed: digitSum('abcCd') == 67" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("helloE") != 69) {\n        std::cerr << "Assertion failed: digitSum('helloE') == 69" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("woArBld") != 131) {\n        std::cerr << "Assertion failed: digitSum('woArBld') == 131" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("aAaaaXa") != 153) {\n        std::cerr << "Assertion failed: digitSum('aAaaaXa') == 153" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum(" How are yOu?") != 151) {\n        std::cerr << "Assertion failed: digitSum(' How are yOu?') == 151" << std::endl;\n        return 1;\n    }\n    \n    if (digitSum("You arE Very Smart") != 327) {\n        std::cerr << "Assertion failed: digitSum('You arE Very Smart') == 327" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n```\n\nThis code includes the `digitSum` function to calculate the sum of ASCII values of uppercase letters in a given string. The main function performs several assertions to ensure the function works correctly, printing an error message and terminating if an assertion fails. If all assertions pass, it outputs a success message.
Here's your Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cctype>\n\n// Function declaration\nint fruit_distribution(const std::string &s, int n);\n\nint main() {\n    std::string s;\n    int n;\n\n    // Test cases\n    s = "5 apples and 6 oranges";\n    n = 19;\n    if (fruit_distribution(s, n) != 8) {\n        std::cout << "Test case 1 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "5 apples and 6 oranges";\n    n = 21;\n    if (fruit_distribution(s, n) != 10) {\n        std::cout << "Test case 2 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "0 apples and 1 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cout << "Test case 3 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 0 oranges";\n    n = 3;\n    if (fruit_distribution(s, n) != 2) {\n        std::cout << "Test case 4 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 100;\n    if (fruit_distribution(s, n) != 95) {\n        std::cout << "Test case 5 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "2 apples and 3 oranges";\n    n = 5;\n    if (fruit_distribution(s, n) != 0) {\n        std::cout << "Test case 6 failed" << std::endl;\n        std::exit(1);\n    }\n\n    s = "1 apples and 100 oranges";\n    n = 120;\n    if (fruit_distribution(s, n) != 19) {\n        std::cout << "Test case 7 failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n\nint fruit_distribution(const std::string &s, int n) {\n    std::string num1, num2;\n    int is12 = 0, num1_val, num2_val;\n\n    for (char c : s) {\n        if (std::isdigit(c)) {\n            if (is12 == 0) {\n                num1 += c;\n            } else if (is12 == 1) {\n                num2 += c;\n            }\n        } else if (is12 == 0 && !num1.empty()) {\n            is12 = 1;\n        }\n    }\n\n    num1_val = std::stoi(num1);\n    num2_val = std::stoi(num2);\n\n    return n - num1_val - num2_val;\n}\n```\n\nExplanation:\n- The main function in C++ contains test cases similar to the Fortran code.\n- The function `fruit_distribution` takes a string and an integer as arguments and returns the result after parsing and subtracting the numbers found in the string from n.\n- String handling, conditional checks, and loop constructs have been translated to the corresponding C++ constructs.\n- `isdigit` is used to check if a character is a digit.\n- `std::stoi` is used to convert the extracted numeric substrings to integers.\n\nThis C++ code should behave the same as the original Fortran code, executing the same test cases and producing the same results.
Sure, here is the equivalent C++ code translated from the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function prototypes\nvoid pluck(const std::vector<int>& arr, std::vector<int>& out);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\n\nint main() {\n    std::vector<int> arr;\n    std::vector<int> result;\n    std::vector<int> empty;\n\n    // Test cases\n    arr = {4, 2, 3};\n    pluck(arr, result);\n    assert(issame(result, {2, 1}));\n\n    arr = {1, 2, 3};\n    pluck(arr, result);\n    assert(issame(result, {2, 1}));\n\n    arr.clear();\n    pluck(arr, result);\n    assert(issame(result, empty));\n\n    arr = {5, 0, 3, 0, 4, 2};\n    pluck(arr, result);\n    assert(issame(result, {0, 1}));\n\n    arr = {1, 2, 3, 0, 5, 3};\n    pluck(arr, result);\n    assert(issame(result, {0, 3}));\n\n    arr = {5, 4, 8, 4, 8};\n    pluck(arr, result);\n    assert(issame(result, {4, 1}));\n\n    arr = {7, 6, 7, 1};\n    pluck(arr, result);\n    assert(issame(result, {6, 1}));\n\n    arr = {7, 9, 7, 1};\n    pluck(arr, result);\n    assert(issame(result, empty));\n\n    std::cout << "All assertions passed!" << std::endl;\n\n    return 0;\n}\n\nvoid pluck(const std::vector<int>& arr, std::vector<int>& out) {\n    out.clear(); // Equivalent to deallocating and reallocating with size 0\n    \n    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && (out.empty() || arr[i] < out[0])) {\n            out = {arr[i], static_cast<int>(i)};\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n```\n\n### Explanation:\n1. **Dynamic Arrays**:\n    - In Fortran, arrays are dynamically allocated using `allocate` and deallocated using `deallocate`.\n    - In C++, vectors from the Standard Template Library (STL) are used for dynamic arrays. They automatically handle dynamic memory allocation and deallocation.\n\n2. **Subroutine `pluck`**:\n    - This subroutine was translated into a C++ function `pluck` that takes a constant reference to a `std::vector<int>` for the input array and a reference to a `std::vector<int>` for the output array. \n    - The function iterates through the input vector to find the even number satisfying the conditions and sets the output vector accordingly.\n\n3. **Function `issame`**:\n    - This Fortran function checks if two arrays are the same. In C++, it's a function that takes two vectors by constant reference and compares their sizes and elements.\n\n4. **Subroutine `assert`**:\n    - Fortran's assert subroutine for checking conditions was replaced by the standard `assert` function in C++.\n\n5. **Main function**:\n    - The main program logic is transferred to the `main` function in C++. The vectors are initialized and cleared as needed for each test case.\n    - The test cases use the `pluck` function and `assert` to ensure the results are as expected.\n\nRunning this C++ program with the given test cases would verify the correctness as done in the original Fortran program.
Below is the provided Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid extend_array(std::vector<std::vector<int>>& array, int new_size) {\n    int current_cols = array[0].size();\n    for (auto& row : array) {\n        row.resize(new_size, 0);\n    }\n}\n\nint search(const std::vector<int>& lst) {\n    int max = -1;\n    std::vector<std::vector<int>> freq(2, std::vector<int>(0));\n    int freq_size = 0;\n    \n    for (int i = 0; i < lst.size(); ++i) {\n        bool has = false;\n        for (int j = 0; j < freq_size; ++j) {\n            if (lst[i] == freq[0][j]) {\n                freq[1][j] += 1;\n                has = true;\n                if (freq[1][j] >= freq[0][j] && freq[0][j] > max) max = freq[0][j];\n            }\n        }\n        \n        if (!has) {\n            freq_size += 1;\n            extend_array(freq, freq_size);\n            freq[0][freq_size - 1] = lst[i];\n            freq[1][freq_size - 1] = 1;\n            if (max == -1 && lst[i] == 1) max = 1;\n        }\n    }\n    return max;\n}\n\nvoid assert_equal(int result, int expected, const std::string& message) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << message << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    assert_equal(search({5, 5, 5, 5, 1}), 1, "search({5, 5, 5, 5, 1}) == 1");\n    assert_equal(search({4, 1, 4, 1, 4, 4}), 4, "search({4, 1, 4, 1, 4, 4}) == 4");\n    assert_equal(search({3, 3}), -1, "search({3, 3}) == -1");\n    assert_equal(search({8, 8, 8, 8, 8, 8, 8, 8}), 8, "search({8, 8, 8, 8, 8, 8, 8, 8}) == 8");\n    assert_equal(search({2, 3, 3, 2, 2}), 2, "search({2, 3, 3, 2, 2}) == 2");\n\n    // Add more assertions as needed...\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Modules and Subroutines**: Fortran modules and subroutines are translated into C++ functions and classes (if needed). Here, we created a couple of functions (`extend_array` and `search`) instead of subroutines.\n\n2. **Array Handling**: Fortran arrays are translated to C++ `std::vector`. The 2D arrays in Fortran are mapped to `std::vector<std::vector<int>>` in C++.\n\n3. **Dynamic Array Resizing**: The `extend_array` subroutine in Fortran allocates more space for the array. In C++, this is handled by the `resize` function of `std::vector`.\n\n4. **Looping and Logical Constructs**: Fortran's `do` loops and logical constructs translate to C++â€™s `for` loops and `if` statements.\n\n5. **Assertions**: Fortran's assertion mechanism using `write` and `exit` is translated to a helper function `assert_equal`.\n\nMake sure you have the necessary headers and compile correctly using a C++ compiler.
Here's the corresponding C++ code for the given Fortran module and program. The translation includes the strange sort function, the equality check function, and the test cases using assertions.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n// Sorting function with a strange reordering\nvoid strange_sort_list(const std::vector<int>& lst, std::vector<int>& out) {\n    int n = lst.size();\n    if (n == 0) {\n        out.clear();\n        return;\n    }\n\n    std::vector<int> sorted_lst = lst;\n    // Bubble sort\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (sorted_lst[j] > sorted_lst[j + 1]) {\n                std::swap(sorted_lst[j], sorted_lst[j + 1]);\n            }\n        }\n    }\n\n    out.resize(n);\n    int l = 0, r = n - 1, i = 0;\n\n    while (l < r) {\n        out[i++] = sorted_lst[l++];\n        out[i++] = sorted_lst[r--];\n    }\n\n    if (l == r) {\n        out[i] = sorted_lst[l];\n    }\n}\n\n// Function to check if two integer vectors are the same\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    return a == b;\n}\n\n// Assert function\nvoid test_assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> out;\n\n    // Test cases\n    strange_sort_list({1, 2, 3, 4}, out);\n    test_assert(issame(out, {1, 4, 2, 3}));\n\n    strange_sort_list({5, 6, 7, 8, 9}, out);\n    test_assert(issame(out, {5, 9, 6, 8, 7}));\n\n    strange_sort_list({1, 2, 3, 4, 5}, out);\n    test_assert(issame(out, {1, 5, 2, 4, 3}));\n\n    strange_sort_list({5, 6, 7, 8, 9, 1}, out);\n    test_assert(issame(out, {1, 9, 5, 8, 6, 7}));\n\n    strange_sort_list({5, 5, 5, 5}, out);\n    test_assert(issame(out, {5, 5, 5, 5}));\n\n    // Handle empty array case separately\n    strange_sort_list({}, out);\n    test_assert(issame(out, {}));\n\n    strange_sort_list({1, 2, 3, 4, 5, 6, 7, 8}, out);\n    test_assert(issame(out, {1, 8, 2, 7, 3, 6, 4, 5}));\n\n    strange_sort_list({0, 2, 2, 2, 5, 5, -5, -5}, out);\n    test_assert(issame(out, {-5, 5, -5, 5, 0, 2, 2, 2}));\n\n    strange_sort_list({111111}, out);\n    test_assert(issame(out, {111111}));\n\n    return 0;\n}\n```\n\n### Notes:\n1. **Sorting**: The `std::sort` function or a custom sorting algorithm like the bubble sort can be used. Here we use a bubble sort to match the original Fortran implementation.\n2. **Dynamic Arrays**: C++ vectors are used to handle dynamic arrays.\n3. **Assertions**: Assertions in C++ can be handled using `assert`.\n4. **Input/Output**: Similar input/output handling is implemented based on standard C++ libraries like `<iostream>` and `<vector>`.
Certainly! Here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <string>\n\ndouble triangle_area(double a, double b, double c) {\n    double area, h;\n    if (a + b <= c || a + c <= b || b + c <= a) {\n        area = -1.0;\n    } else {\n        h = (a + b + c) / 2.0;\n        area = std::sqrt(h * (h - a) * (h - b) * (h - c));\n    }\n    return area;\n}\n\nvoid check_assertion(bool condition, const std::string &message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    check_assertion(std::abs(triangle_area(3.0, 4.0, 5.0) - 6.0) < 0.01, "Assertion failed: triangle_area(3, 4, 5)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 10)");\n    check_assertion(std::abs(triangle_area(4.0, 8.0, 5.0) - 8.18) < 0.01, "Assertion failed: triangle_area(4, 8, 5)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 2.0) - 1.73) < 0.01, "Assertion failed: triangle_area(2, 2, 2)");\n    check_assertion(std::abs(triangle_area(1.0, 2.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(1, 2, 3)");\n    check_assertion(std::abs(triangle_area(10.0, 5.0, 7.0) - 16.25) < 0.01, "Assertion failed: triangle_area(10, 5, 7)");\n    check_assertion(std::abs(triangle_area(2.0, 6.0, 3.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 6, 3)");\n    check_assertion(std::abs(triangle_area(1.0, 1.0, 1.0) - 0.43) < 0.01, "Assertion failed: triangle_area(1, 1, 1)");\n    check_assertion(std::abs(triangle_area(2.0, 2.0, 10.0) + 1.0) < 0.01, "Assertion failed: triangle_area(2, 2, 10)");\n\n    return 0;\n}\n```\n\nThis C++ code replicates the functionality of the Fortran program. It checks the area of various triangles using Heron's formula, and if the calculated area does not match the expected value within a given tolerance (0.01), it will print an error message and exit the program.
Here is the C++ translation of the given Fortran code:\n\n```c++\n#include <iostream>\n#include <vector>\n#include <numeric>  // For std::accumulate\n\nbool will_it_fly(const std::vector<int>& q, int w) {\n    int sum = 0;\n    int n = q.size();\n\n    // Check if the array is a palindrome\n    for (int i = 0; i < n; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n        sum += q[i];\n    }\n\n    // Check if the sum exceeds w\n    if (sum > w) {\n        return false;\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> q;\n    int w;\n\n    // Test case 1\n    q = {3, 2, 3};\n    w = 9;\n    if (!will_it_fly(q, w)) {\n        std::cout << "Test case 1 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    q = {1, 2};\n    w = 5;\n    if (will_it_fly(q, w)) {\n        std::cout << "Test case 2 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    q = {3};\n    w = 5;\n    if (!will_it_fly(q, w)) {\n        std::cout << "Test case 3 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 4\n    q = {3, 2, 3};\n    w = 1;\n    if (will_it_fly(q, w)) {\n        std::cout << "Test case 4 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 5\n    q = {1, 2, 3};\n    w = 6;\n    if (will_it_fly(q, w)) {\n        std::cout << "Test case 5 failed" << std::endl;\n        return 1;\n    }\n\n    // Test case 6\n    q = {5};\n    w = 5;\n    if (!will_it_fly(q, w)) {\n        std::cout << "Test case 6 failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All test cases passed" << std::endl;\n    return 0;\n}\n```\n\nExplanation:\n1. The function `will_it_fly` in C++ takes a `std::vector<int>` and an integer `w` as its arguments.\n2. It checks if the vector `q` is a palindrome and calculates its sum.\n3. If the vector is not a palindrome or if the sum of its elements exceeds `w`, it returns `false`.\n4. The `main` function tests the function with various test cases, similar to the Fortran code's `program main`.\n5. If any of the test cases fail, it prints an error message and exits with a non-zero status.\n6. If all test cases pass, it prints a success message and exits with a zero status.
Certainly! Here is the equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint smallest_change(const std::vector<int>& arr) {\n    int out = 0;\n    int n = arr.size();\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (arr[i] != arr[n - 1 - i]) {\n            ++out;\n        }\n    }\n\n    return out;\n}\n\nvoid assert_equal(int result, int expected, const std::string& msg) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << msg << " == " << expected << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    int result;\n\n    result = smallest_change({1, 2, 3, 5, 4, 7, 9, 6});\n    assert_equal(result, 4, "smallest_change({1, 2, 3, 5, 4, 7, 9, 6})");\n\n    result = smallest_change({1, 2, 3, 4, 3, 2, 2});\n    assert_equal(result, 1, "smallest_change({1, 2, 3, 4, 3, 2, 2})");\n\n    result = smallest_change({1, 4, 2});\n    assert_equal(result, 1, "smallest_change({1, 4, 2})");\n\n    result = smallest_change({1, 4, 4, 2});\n    assert_equal(result, 1, "smallest_change({1, 4, 4, 2})");\n\n    result = smallest_change({1, 2, 3, 2, 1});\n    assert_equal(result, 0, "smallest_change({1, 2, 3, 2, 1})");\n\n    result = smallest_change({3, 1, 1, 3});\n    assert_equal(result, 0, "smallest_change({3, 1, 1, 3})");\n\n    result = smallest_change({1});\n    assert_equal(result, 0, "smallest_change({1})");\n\n    result = smallest_change({0, 1});\n    assert_equal(result, 1, "smallest_change({0, 1})");\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n- **Function Translation**: The `smallest_change` function directly translates from Fortran to C++, where the loop is adapted for zero-based indexing.\n- **Assertions**: Used a helper function `assert_equal` to check if the computed results match expected values and print the respective error message.\n- **I/O Operations**: Uses `std::cerr` for error output and `std::cout` for the final success message.\n- **Vector Initialization**: Leveraged C++'s initializer list syntax to pass vector literals to the `smallest_change` function.\n\nThis C++ program should behave equivalently to the given Fortran program.
Here's the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\nstd::string pad(const std::string& str, std::size_t len) {\n    return str + std::string(len - str.size(), ' ');\n}\n\nstd::vector<std::string> total_match(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    std::size_t num1 = 0;\n    std::size_t num2 = 0;\n\n    for (const auto& item : lst1) {\n        num1 += item.size();\n    }\n\n    for (const auto& item : lst2) {\n        num2 += item.size();\n    }\n\n    if (num1 > num2) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (std::size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid runTests() {\n    std::vector<std::string> empty;\n\n    // Test cases\n    assert(issame(total_match({ pad("hi", 100), pad("admin", 100) }, { pad("hi", 100), pad("hi", 100) }), { pad("hi", 100), pad("hi", 100) }));\n    assert(issame(total_match({ pad("hi", 100), pad("admin", 100) }, { pad("hi", 100), pad("hi", 100), pad("admin", 100), pad("project", 100) }), { pad("hi", 100), pad("admin", 100) }));\n    assert(issame(total_match({ pad("4", 100) }, { pad("1", 100), pad("2", 100), pad("3", 100), pad("4", 100), pad("5", 100) }), { pad("4", 100) }));\n    assert(issame(total_match({ pad("hi", 100), pad("admin", 100) }, { pad("hI", 100), pad("Hi", 100) }), { pad("hI", 100), pad("Hi", 100) }));\n    assert(issame(total_match({ pad("hi", 100), pad("admin", 100) }, { pad("hI", 100), pad("hi", 100), pad("hi", 100) }), { pad("hI", 100), pad("hi", 100), pad("hi", 100) }));\n    assert(issame(total_match({ pad("hi", 100), pad("admin", 100) }, { pad("hI", 100), pad("hi", 100), pad("hii", 100) }), { pad("hi", 100), pad("admin", 100) }));\n    assert(issame(total_match(empty, { pad("this", 100) }), empty));\n    assert(issame(total_match({ pad("this", 100) }, empty), empty));\n\n    std::cout << "All tests passed!" << std::endl;\n}\n\nint main() {\n    runTests();\n    return 0;\n}\n```\n\nExplanation:\n- The `pad` function pads the string to the specified length with spaces.\n- The `total_match` function calculates the total length of the non-whitespace characters in each list and returns the list with the smaller total length.\n- The `issame` function checks if two vectors of strings have the same trimmed content.\n- The `runTests` function runs the test cases using `assert` to verify the correctness of the implementation.\n\nIn this code, `std::string` is used to manage strings, and `std::vector<std::string>` manages the dynamic lists (analogous to Fortran allocatable arrays). `assert` is used for test validation similar to the Fortran `assert` subroutine.
Sure! Below is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for std::exit\n\nbool is_simple_power(int x, int n) {\n    int p = 1;\n    int count = 0;\n\n    while (p <= x && count < 100) {\n        if (p == x) {\n            return true;\n        }\n        p = p * n;\n        count++;\n    }\n    return false;\n}\n\nint main() {\n    // Test cases\n    if (!is_simple_power(1, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 4) == true" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(2, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(2, 2) == true" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(8, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(8, 2) == true" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(3, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 2) == false" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(3, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(3, 1) == false" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(5, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(5, 3) == false" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(16, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 2) == true" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(143214, 16)) {\n        std::cerr << "Assertion failed: is_simple_power(143214, 16) == false" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(4, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(4, 2) == true" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(9, 3)) {\n        std::cerr << "Assertion failed: is_simple_power(9, 3) == true" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(16, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(16, 4) == true" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(24, 2)) {\n        std::cerr << "Assertion failed: is_simple_power(24, 2) == false" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(128, 4)) {\n        std::cerr << "Assertion failed: is_simple_power(128, 4) == false" << std::endl;\n        std::exit(1);\n    }\n    if (is_simple_power(12, 6)) {\n        std::cerr << "Assertion failed: is_simple_power(12, 6) == false" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(1, 1)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 1) == true" << std::endl;\n        std::exit(1);\n    }\n    if (!is_simple_power(1, 12)) {\n        std::cerr << "Assertion failed: is_simple_power(1, 12) == true" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All test cases passed!" << std::endl;\n    return 0;\n}\n```\n\nIn this C++ code, the function `is_simple_power` checks if one number is a simple power of another using a loop with a counter limit, similar to the original Fortran implementation. Assertions are used to validate the function's correctness, and an error message is printed before exiting if any assertion fails.
Sure! Below is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nbool iscuber(int a) {\n    int upperLimit = static_cast<int>(std::pow(std::abs(a), 1.0 / 3.0));\n    for (int i = 0; i <= upperLimit; ++i) {\n        if (i * i * i == std::abs(a)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Assertions\n    if (!iscuber(1)) {\n        std::cerr << "iscuber(1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(2)) {\n        std::cerr << "iscuber(2): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(-1)) {\n        std::cerr << "iscuber(-1): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(64)) {\n        std::cerr << "iscuber(64): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(180)) {\n        std::cerr << "iscuber(180): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(1000)) {\n        std::cerr << "iscuber(1000): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (!iscuber(0)) {\n        std::cerr << "iscuber(0): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    if (iscuber(1729)) {\n        std::cerr << "iscuber(1729): assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nExplanation:\n\n1. **Function `iscuber`**:\n   - Returns `true` if the integer `a` is a perfect cube, otherwise returns `false`.\n   - Calculated `upperLimit` for the loop, equivalent to `int(abs(a)**(1.0/3.0))` in Fortran.\n\n2. **Assertions in `main`**:\n   - Uses standard C++ streams for input/output (`std::cout` and `std::cerr`).\n   - Exits the program with a non-zero exit code if any assertion fails by using `std::exit(1)`.\n\nOther considerations:\n- Includes the necessary headers (`<iostream>`, `<cmath>`, `<cstdlib>`).\n- The main function follows a similar logic to check the assertions as in the Fortran program.
Translating the Fortran code to C++ involves several steps, including translating the program structure, converting subroutines into C++ functions, and properly handling character and string operations. Below is the translated C++ code, preserving the same logic:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string key = "2357BD";\n\n// Function to count occurrences of key characters in the hex string\nint hex_key(const std::string& num) {\n    int out = 0;\n    for (char ch : num) {\n        if (key.find(ch) != std::string::npos) {\n            out++;\n        }\n    }\n    return out;\n}\n\n// Main program\nint main() {\n    // Assertions\n    assert(hex_key("AB") == 1);\n    assert(hex_key("1077E") == 2);\n    assert(hex_key("ABED1A33") == 4);\n    assert(hex_key("2020") == 2);\n    assert(hex_key("123456789ABCDEF0") == 6);\n    assert(hex_key("112233445566778899AABBCCDDEEFF00") == 12);\n    assert(hex_key("") == 0);\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\nHere's a breakdown of some key points in the translation:\n\n1. **String Handling**: In C++, `std::string` is used to handle strings instead of Fortran's `character(len=*)`.\n2. **For Loops and Character Comparison**: The Fortran `do` loop and `character` checking with `index` are translated in C++ using a `for` loop and `std::string::find`.\n3. **Assertions**: Fortran's `assert` subroutine translates naturally to C++'s `assert` function.\n\nRun this C++ code in a suitable environment to ensure functionality analogous to the provided Fortran code.
Sure, here's the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\n// Function prototype\nstd::string decimal_to_binary(int decimal);\n\nvoid test_decimal_to_binary() {\n    std::string result;\n\n    result = decimal_to_binary(0);\n    assert(result == "db0db" && "Assertion failed: decimal_to_binary(0) == 'db0db'");\n\n    result = decimal_to_binary(32);\n    assert(result == "db100000db" && "Assertion failed: decimal_to_binary(32) == 'db100000db'");\n\n    result = decimal_to_binary(103);\n    assert(result == "db1100111db" && "Assertion failed: decimal_to_binary(103) == 'db1100111db'");\n\n    result = decimal_to_binary(15);\n    assert(result == "db1111db" && "Assertion failed: decimal_to_binary(15) == 'db1111db'");\n\n    std::cout << "All assertions passed." << std::endl;\n}\n\nstd::string decimal_to_binary(int decimal) {\n    if (decimal == 0) {\n        return "db0db";\n    }\n\n    std::string binary;\n    int temp = decimal;\n\n    while (temp > 0) {\n        binary = std::to_string(temp % 2) + binary;\n        temp /= 2;\n    }\n\n    return "db" + binary + "db";\n}\n\nint main() {\n    test_decimal_to_binary();\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Decimal to Binary Function (`decimal_to_binary`)**:\n   - If the input decimal is `0`, return the string `"db0db"`.\n   - Otherwise, compute the binary representation of the decimal number and prepend `db` and append `db` to the result.\n\n2. **Test Function (`test_decimal_to_binary`)**:\n   - Tests the `decimal_to_binary` function with specific cases using assertions to check the results.\n\n3. **Main Function**:\n   - Calls `test_decimal_to_binary` to execute the tests and print a message if all assertions pass.\n\nThis C++ version should work equivalently to the provided Fortran code.
Here is the translation of the provided Fortran code to C++:\n\n```c++\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool is_happy(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    for (size_t i = 2; i < s.length(); ++i) {\n        if (s[i] == s[i-1] || s[i] == s[i-2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    // Test cases\n    if (!is_happy("a")) {\n        std::cout << "Test 1 passed" << std::endl;\n    } else {\n        std::cout << "Test 1 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("aa")) {\n        std::cout << "Test 2 passed" << std::endl;\n    } else {\n        std::cout << "Test 2 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("abcd")) {\n        std::cout << "Test 3 passed" << std::endl;\n    } else {\n        std::cout << "Test 3 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("aabb")) {\n        std::cout << "Test 4 passed" << std::endl;\n    } else {\n        std::cout << "Test 4 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("adb")) {\n        std::cout << "Test 5 passed" << std::endl;\n    } else {\n        std::cout << "Test 5 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("xyy")) {\n        std::cout << "Test 6 passed" << std::endl;\n    } else {\n        std::cout << "Test 6 failed" << std::endl;\n        return 1;\n    }\n\n    if (is_happy("iopaxpoi")) {\n        std::cout << "Test 7 passed" << std::endl;\n    } else {\n        std::cout << "Test 7 failed" << std::endl;\n        return 1;\n    }\n\n    if (!is_happy("iopaxioi")) {\n        std::cout << "Test 8 passed" << std::endl;\n    } else {\n        std::cout << "Test 8 failed" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nExplanation:\n- The `is_happy` function in C++ has the same logic as in Fortran. It returns `false` if the string length is less than 3 or if any character is the same as the previous two characters.\n- The `main` function performs the same set of tests as in the Fortran program using the `is_happy` function and outputs the results accordingly. If any test fails, it exits with a return code of 1.
Below is the translated C++ code for the given Fortran program. The C++ code includes the necessary conversions and adaptations to mimic the same functionality. Note that Fortran array and indexing behavior are adjusted to fit C++ conventions, and the dynamic array allocation in Fortran is done using `std::vector<std::string>` in C++.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> numerical_letter_grade(const std::vector<double>& grades) {\n    std::vector<std::string> out(grades.size());\n\n    for (size_t i = 0; i < grades.size(); ++i) {\n        if (grades[i] >= 3.9999) {\n            out[i] = "A+";\n        } else if (grades[i] > 3.7001 && grades[i] < 3.9999) {\n            out[i] = "A ";\n        } else if (grades[i] > 3.3001 && grades[i] <= 3.7001) {\n            out[i] = "A-";\n        } else if (grades[i] > 3.0001 && grades[i] <= 3.3001) {\n            out[i] = "B+";\n        } else if (grades[i] > 2.7001 && grades[i] <= 3.0001) {\n            out[i] = "B ";\n        } else if (grades[i] > 2.3001 && grades[i] <= 2.7001) {\n            out[i] = "B-";\n        } else if (grades[i] > 2.0001 && grades[i] <= 2.3001) {\n            out[i] = "C+";\n        } else if (grades[i] > 1.7001 && grades[i] <= 2.0001) {\n            out[i] = "C ";\n        } else if (grades[i] > 1.3001 && grades[i] <= 1.7001) {\n            out[i] = "C-";\n        } else if (grades[i] > 1.0001 && grades[i] <= 1.3001) {\n            out[i] = "D+";\n        } else if (grades[i] > 0.7001 && grades[i] <= 1.0001) {\n            out[i] = "D ";\n        } else if (grades[i] > 0.0001 && grades[i] <= 0.7001) {\n            out[i] = "D-";\n        } else {\n            out[i] = "E ";\n        }\n    }\n    return out;\n}\n\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::string> result;\n    std::vector<std::string> expected1 = {"A+", "B ", "C-", "C ", "A-"};\n    std::vector<std::string> expected2 = {"D+"};\n    std::vector<std::string> expected3 = {"D-"};\n    std::vector<std::string> expected4 = {"E "};\n    std::vector<std::string> expected5 = {"D ", "D-", "C-", "B ", "B+"};\n    std::vector<std::string> expected6 = {"E ", "D-"};\n\n    result = numerical_letter_grade({4.0, 3.0, 1.7, 2.0, 3.5});\n    if (!issame(result, expected1)) {\n        std::cout << "Assertion failed for test case 1" << std::endl;\n        return 1;\n    }\n\n    result = numerical_letter_grade({1.2});\n    if (!issame(result, expected2)) {\n        std::cout << "Assertion failed for test case 2" << std::endl;\n        return 1;\n    }\n\n    result = numerical_letter_grade({0.5});\n    if (!issame(result, expected3)) {\n        std::cout << "Assertion failed for test case 3" << std::endl;\n        return 1;\n    }\n\n    result = numerical_letter_grade({0.0});\n    if (!issame(result, expected4)) {\n        std::cout << "Assertion failed for test case 4" << std::endl;\n        return 1;\n    }\n\n    result = numerical_letter_grade({1.0, 0.3, 1.5, 2.8, 3.3});\n    if (!issame(result, expected5)) {\n        std::cout << "Assertion failed for test case 5" << std::endl;\n        return 1;\n    }\n\n    result = numerical_letter_grade({0.0, 0.7});\n    if (!issame(result, expected6)) {\n        std::cout << "Assertion failed for test case 6" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ program replicates the functionality of the Fortran program. It defines a function `numerical_letter_grade` that maps numeric grades to letter grades and a function `issame` to compare two vectors of strings. The main function runs several test cases and checks whether the results match the expected outputs, printing messages and exiting with an error code if any assertion fails.
The following is the equivalent C++ code obtained by directly translating the Fortran code. This includes transforming the program structure, array handling, loop constructs, string manipulation, and the logical and function statements used:\n```cpp\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\n// Function declaration\nbool is_prime_length(const std::string &s) {\n    int l = s.length();\n    if (l < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= std::sqrt(l); ++i) {\n        if (l % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid run_tests() {\n    std::string str;\n    bool result;\n\n    str = "Hello";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Hello') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "abcdcba";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('abcdcba') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "kittens";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('kittens') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "orange";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('orange') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "wow";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('wow') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "world";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('world') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "MadaM";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('MadaM') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "Wow";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Wow') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "HI";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('HI') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "go";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('go') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "gogo";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('gogo') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "aaaaaaaaaaaaaaa";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('aaaaaaaaaaaaaaa') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "Madam";\n    result = is_prime_length(str);\n    if (!result) {\n        std::cerr << "is_prime_length('Madam') == true: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "M";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('M') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    str = "0";\n    result = is_prime_length(str);\n    if (result) {\n        std::cerr << "is_prime_length('0') == false: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed successfully." << std::endl;\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Structure**: The `program` and `contains` sections in Fortran are replaced by a main function and direct function definitions in C++. The `run_tests` subroutine is directly translated into a C++ function.\n  \n2. **Characters and Strings**: Fortran strings are handled using `character(len=*)` and `len_trim`. In C++, the `std::string` class provides this functionality.\n\n3. **Control Structures**:\n   - **Loops**: The `do` loop in Fortran is replaced with `for` loops in C++.\n   - **Conditions**: Fortran `if` conditions, `then, end if` are translated into C++ `if` statements.\n\n4. **Mathematical Functions**: The Fortran intrinsic functions like `sqrt`, `real` are replaced using C++ standard library functions `std::sqrt`.\n\n5. **Input/Output**: Fortran's `write(*,*)` to print to console is replaced using `std::cout` for success messages and `std::cerr` for assertion failures.\n\n6. **Exit**: Fortran's `call exit(x)` is replaced with `std::exit(x)`.\n\nThis code should correctly replicate the Fortran logic in C++.
Here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n\nint starts_one_ends(int n);\n\nint main() {\n    // Assertions\n    if (starts_one_ends(1) != 1) {\n        std::cout << "Assertion failed: starts_one_ends(1) == 1" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(2) != 18) {\n        std::cout << "Assertion failed: starts_one_ends(2) == 18" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(3) != 180) {\n        std::cout << "Assertion failed: starts_one_ends(3) == 180" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(4) != 1800) {\n        std::cout << "Assertion failed: starts_one_ends(4) == 1800" << std::endl;\n        std::exit(1);\n    }\n\n    if (starts_one_ends(5) != 18000) {\n        std::cout << "Assertion failed: starts_one_ends(5) == 18000" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n\nint starts_one_ends(int n) {\n    if (n < 1) {\n        return 0;\n    }\n\n    if (n == 1) {\n        return 1;\n    }\n\n    int out = 18;\n    for (int i = 2; i < n; ++i) {\n        out *= 10;\n    }\n\n    return out;\n}\n```\n\n### Explanation:\n\n1. **Function Declaration and Definition**: In Fortran, the function definition was inline with the `main` program using the `contains` keyword. In C++, I have moved the function declaration before the `main` function and provided the definition after it.\n   \n2. **Implicit None**: In C++, variables must be explicitly declared, so there's no need for something equivalent to `implicit none` in Fortran.\n   \n3. **Assertions**: The assertions are performed using `if` statements, similar to Fortran, but with C++'s `std::cout` for output and `std::exit` for exiting the program.\n\n4. **Loops**: The `do` loop in Fortran translates directly to a `for` loop in C++ with similar semantics. \n\n5. **Function Logic**: The main logic of the function `starts_one_ends` was straightforward to translate from Fortran to C++. The arithmetic and control flow statements have direct equivalents in C++. \n\nThis C++ code is now functionally equivalent to the given Fortran code.
Here is the translated Fortran code in C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <cstdlib>\n\nstd::string solve(int N);\n\nint main() {\n    std::string result;\n\n    result = solve(1000);\n    if (result != "1") {\n        std::cerr << "Assertion failed for solve(1000)" << std::endl;\n        return 1;\n    }\n\n    result = solve(150);\n    if (result != "110") {\n        std::cerr << "Assertion failed for solve(150)" << std::endl;\n        return 1;\n    }\n\n    result = solve(147);\n    if (result != "1100") {\n        std::cerr << "Assertion failed for solve(147)" << std::endl;\n        return 1;\n    }\n\n    result = solve(333);\n    if (result != "1001") {\n        std::cerr << "Assertion failed for solve(333)" << std::endl;\n        return 1;\n    }\n\n    result = solve(963);\n    if (result != "10010") {\n        std::cerr << "Assertion failed for solve(963)" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nstd::string solve(int N) {\n    std::ostringstream oss;\n    oss << N;\n    std::string str = oss.str();\n\n    int sum = 0;\n    for (char ch : str) {\n        sum += ch - '0';\n    }\n\n    std::string bi;\n    while (sum > 0) {\n        bi = std::to_string(sum % 2) + bi;\n        sum /= 2;\n    }\n\n    if (bi.empty()) {\n        bi = "0";\n    }\n\n    return bi;\n}\n```\n\n### Key Points of Translation\n1. **Main Program Structure**: C++ uses `int main()` function to mark the entry point of the program. Assertions and error handling are done using standard I/O streams and returning from the function if necessary.\n2. **String Handling**: C++ has richer string handling capabilities compared to Fortran. `std::ostringstream` is used for converting the integer to a string.\n3. **Looping and Conditional Constructs**: The loops and conditionals in Fortran directly map to `for`, `while`, and `if` statements in C++.\n4. **Type Conversion and Character Operations**: Characters in C++ strings can be manipulated using simple arithmetic operations.\n5. **Binary Conversion**: The `to_string` method converts an integer to its string representation, analogous to writing into a single-character string in Fortran.\n\nThe resulting C++ code is structured to maintain the functional logic of the original Fortran code with appropriate use of C++ standard libraries and idioms.
To translate the provided Fortran code to C++, there are several steps involved: setting up the main function, defining the `add` function, and performing the test cases with assertions. Here's the equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nint add(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < (lst.size() + 1) / 2; ++i) {\n        size_t index = 2 * i + 1;\n        if (index < lst.size() && lst[index] % 2 == 0) {\n            sum += lst[index];\n        }\n    }\n    return sum;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = add({4, 88});\n    assert(result == 88 && "Assertion failed: add({4, 88}) == 88");\n\n    result = add({4, 5, 6, 7, 2, 122});\n    assert(result == 122 && "Assertion failed: add({4, 5, 6, 7, 2, 122}) == 122");\n\n    result = add({4, 0, 6, 7});\n    assert(result == 0 && "Assertion failed: add({4, 0, 6, 7}) == 0");\n\n    result = add({4, 4, 6, 8});\n    assert(result == 12 && "Assertion failed: add({4, 4, 6, 8}) == 12");\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\n**Explanation:**\n\n1. **Function Definition**:\n    - The `add` function takes a `std::vector<int>` as input and iterates through it. It checks the even-indexed elements (in 1-based indexing, these correspond to the elements at `2 * i + 2` in Fortran, which is `2 * i + 1` in 0-based C++ indexing).\n    - It sums up the even numbers from these positions.\n\n2. **Main Function**:\n    - The `main` function executes several test cases.\n    - Each test case computes the result using the `add` function and verifies it using `assert`.\n    - If any `assert` fails, the program terminates with an assertion failure message.\n    - On success, it prints a message indicating all tests passed.\n\nThis conversion ensures that the logic and functionality from the Fortran code are preserved in the C++ code.
Certainly! Below is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nstd::vector<int> sort_array(const std::vector<int>& array) {\n    int n = array.size();\n    std::vector<int> out = array;\n\n    if (n == 0) {\n        return out;\n    }\n\n    // Bubble sort implementation\n    for (int i = 0; i < n - 1; ++i) {\n        for (int j = 0; j < n - i - 1; ++j) {\n            if (out[j] > out[j + 1]) {\n                std::swap(out[j], out[j + 1]);\n            }\n        }\n    }\n\n    if ((out[0] + out[n - 1]) % 2 == 1) {\n        return out;\n    } else {\n        std::reverse(out.begin(), out.end());\n        return out;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid test_cases() {\n    assert_condition(issame(sort_array({0}), {0}));\n    assert_condition(issame(sort_array({5}), {5}));\n    assert_condition(issame(sort_array({2, 4, 3, 0, 1, 5}), {0, 1, 2, 3, 4, 5}));\n    assert_condition(issame(sort_array({2, 4, 3, 0, 1, 5, 6}), {6, 5, 4, 3, 2, 1, 0}));\n    assert_condition(issame(sort_array({2, 1}), {1, 2}));\n    assert_condition(issame(sort_array({15, 42, 87, 32, 11, 0}), {0, 11, 15, 32, 42, 87}));\n    assert_condition(issame(sort_array({21, 14, 23, 11}), {23, 21, 14, 11}));\n}\n\nint main() {\n    test_cases();\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Bubble Sort**: Implemented the same Bubble Sort algorithm that was used in the Fortran code.\n2. **`sort_array` Function**: Translated to a function that takes a `std::vector<int>` and returns a `std::vector<int>`.\n3. **`issame` Function**: Checks if two vectors are the same.\n4. **`assert_condition` Function**: Provides assertion functionality to match the Fortran assert subroutine.\n5. **`test_cases` Function**: Contains the test cases to validate the functionality.\n6. **`main` Function**: Calls the `test_cases` function and indicates success if no assertions fail.\n\nThis code should behave similarly to the original Fortran version.
Here's the equivalent C++ code for the provided Fortran module and program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n\nnamespace utilities {\n\nint next_smallest(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    std::vector<int> sorted_lst(lst);\n    std::sort(sorted_lst.begin(), sorted_lst.end());\n\n    for (size_t i = 1; i < sorted_lst.size(); ++i) {\n        if (sorted_lst[i] != sorted_lst[i-1]) {\n            return sorted_lst[i];\n        }\n    }\n    return -1;\n}\n\n}  // namespace utilities\n\nint main() {\n    std::vector<int> lst;\n    int result;\n\n    // Test case 1\n    lst = {1, 2, 3, 4, 5};\n    result = utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cout << "Test case 1 failed\n";\n        return 1;\n    }\n\n    // Test case 2\n    lst = {5, 1, 4, 3, 2};\n    result = utilities::next_smallest(lst);\n    if (result != 2) {\n        std::cout << "Test case 2 failed\n";\n        return 1;\n    }\n\n    // Test case 3\n    lst.clear();\n    result = utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cout << "Test case 3 failed\n";\n        return 1;\n    }\n\n    // Test case 4\n    lst = {1, 1};\n    result = utilities::next_smallest(lst);\n    if (result != -1) {\n        std::cout << "Test case 4 failed\n";\n        return 1;\n    }\n\n    // Test case 5\n    lst = {1, 1, 1, 1, 0};\n    result = utilities::next_smallest(lst);\n    if (result != 1) {\n        std::cout << "Test case 5 failed\n";\n        return 1;\n    }\n\n    // Test case 6\n    lst = {-35, 34, 12, -45};\n    result = utilities::next_smallest(lst);\n    if (result != -35) {\n        std::cout << "Test case 6 failed\n";\n        return 1;\n    }\n\n    std::cout << "All test cases passed\n";\n    return 0;\n}\n```\n\n### Breakdown:\n1. **Namespace Conversion**:\n   - The Fortran `module` has been converted into a C++ `namespace` named `utilities`.\n\n2. **Function (`next_smallest`) Conversion**:\n   - The function is defined under the namespace. It accepts a constant reference to a vector and returns an integer.\n   - The `allocate` and deallocation of arrays is handled internally by the vector structure in C++.\n   - The sort operation is done using the `std::sort` function.\n\n3. **Test Cases**:\n   - Test cases in the `main` function assign appropriate values to the `lst` vector and validate the `next_smallest` function's result.\n   - If a test case fails, an appropriate message is printed, and the program exits with a non-zero status.\n\n### Key Points:\n- **Vectors**: Used to handle dynamic arrays comfortably. Supports `sort` with ease.\n- **Sorting**: The `std::sort` algorithm is utilized, which is part of the `<algorithm>` header.\n- **Immediate Execution**: Logical checks and return status are performed similar to the Fortran program.\n\nThis C++ program should mimic the logic and structure of the original Fortran code while adhering to C++ idiomatic practices.
Sure! Here is the equivalent C++ code translated from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint is_bored(const std::string& S) {\n    bool isstart = true;\n    bool isi = false;\n    int sum = 0;\n    int lenS = S.length();\n\n    for (int i = 0; i < lenS; ++i) {\n        if (S[i] == ' ' && isi) {\n            isi = false;\n            sum++;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = true;\n        } else {\n            isi = false;\n        }\n        if (S[i] != ' ') {\n            isstart = false;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = true;\n        }\n    }\n\n    return sum;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert(is_bored("Hello world") == 0);\n    assert(is_bored("Is the sky blue?") == 0);\n    assert(is_bored("I love It !") == 1);\n    assert(is_bored("bIt") == 0);\n    assert(is_bored("I feel good today. I will be productive. will kill It") == 2);\n    assert(is_bored("You and I are going for a walk") == 0);\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function Definition**: The `is_bored` function in C++ corresponds to the Fortran function `is_bored`. It takes a `std::string` as input instead of a Fortran character string.\n2. **Loop**: The Fortran `do` loop is translated into a C++ `for` loop.\n3. **Character Comparison**: The Fortran `S(i:i) == ' '` is translated to `S[i] == ' '` in C++.\n4. **Boolean Flags**: The logic with `isstart` and `isi` is directly translated to C++ boolean logic.\n5. **String Length**: `len_trim(S)` in Fortran is approximately equivalent to `S.length()` in C++, assuming there are no trailing spaces to trim in this context.\n6. **Assertions**: The `assert` subroutine in Fortran is translated to a function `void assert(bool condition)` in C++ that uses `std::cerr` for output and `exit(1)` for termination.\n7. **Main Function**: The `main` function runs all the test cases to ensure correctness, similar to the original Fortran program unit.
Here's the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n\nbool any_int(double a, double b, double c) {\n    if (std::nearbyint(a) != a) {\n        return false;\n    }\n    if (std::nearbyint(b) != b) {\n        return false;\n    }\n    if (std::nearbyint(c) != c) {\n        return false;\n    }\n    if ((a + b == c) || (a + c == b) || (b + c == a)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    bool result;\n\n    result = any_int(2.0, 3.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 3, 1) == true" << std::endl;\n        return 1;\n    }\n\n    result = any_int(2.5, 2.0, 3.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.5, 2, 3) == false" << std::endl;\n        return 1;\n    }\n\n    result = any_int(1.5, 5.0, 3.5);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(1.5, 5, 3.5) == false" << std::endl;\n        return 1;\n    }\n\n    result = any_int(2.0, 6.0, 2.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2, 6, 2) == false" << std::endl;\n        return 1;\n    }\n\n    result = any_int(4.0, 2.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(4, 2, 2) == true" << std::endl;\n        return 1;\n    }\n\n    result = any_int(2.2, 2.2, 2.2);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(2.2, 2.2, 2.2) == false" << std::endl;\n        return 1;\n    }\n\n    result = any_int(-4.0, 6.0, 2.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(-4, 6, 2) == true" << std::endl;\n        return 1;\n    }\n\n    result = any_int(2.0, 1.0, 1.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(2, 1, 1) == true" << std::endl;\n        return 1;\n    }\n\n    result = any_int(3.0, 4.0, 7.0);\n    if (!result) {\n        std::cerr << "Assertion failed: any_int(3, 4, 7) == true" << std::endl;\n        return 1;\n    }\n\n    result = any_int(3.01, 4.0, 7.0);\n    if (result) {\n        std::cerr << "Assertion failed: any_int(3.01, 4, 7) == false" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n**Explanation:**\n1. The function `any_int` in Fortran was converted to a C++ function of the same name.\n2. The Fortran-specific `nint` function was replaced with `std::nearbyint` from the C++ standard library.\n3. The Fortran logical data type `.true.` and `.false.` were replaced with `true` and `false` in C++.\n4. The main testing program was translated line by line to handle the logical tests and assertions using `std::cerr` for error messages and `return 1` for exiting with failure.
Sure, I'll translate the provided Fortran code to C++. The function `skjkasdkd` is used to find the largest prime number in a list and then sum the digits of that number, returning the sum.\n\nHere is the C++ version of your provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <cstdlib>\n\n// Function to check if a number is prime\nbool is_prime(int number) {\n    if (number <= 1) return false;\n    if (number == 2) return true;\n    if (number % 2 == 0) return false;\n    for (int i = 3; i <= static_cast<int>(std::sqrt(number)); i += 2) {\n        if (number % i == 0) return false;\n    }\n    return true;\n}\n\n// Function to find the largest prime and sum its digits\nint skjkasdkd(const std::vector<int>& lst) {\n    int largest = 0;\n    for (int num : lst) {\n        if (num > largest && is_prime(num)) {\n            largest = num;\n        }\n    }\n\n    int sum = 0;\n    std::string largest_str = std::to_string(largest);\n    for (char c : largest_str) {\n        sum += c - '0';\n    }\n\n    return sum;\n}\n\nint main() {\n    int result;\n\n    result = skjkasdkd({0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3});\n    if (result != 10) {\n        std::cout << "Assertion failed: result /= 10" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1});\n    if (result != 25) {\n        std::cout << "Assertion failed: result /= 25" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3});\n    if (result != 13) {\n        std::cout << "Assertion failed: result /= 13" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({0,724,32,71,99,32,6,0,5,91,83,0,5,6});\n    if (result != 11) {\n        std::cout << "Assertion failed: result /= 11" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({0,81,12,3,1,21});\n    if (result != 3) {\n        std::cout << "Assertion failed: result /= 3" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({0,8,1,2,1,7});\n    if (result != 7) {\n        std::cout << "Assertion failed: result /= 7" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({8191});\n    if (result != 19) {\n        std::cout << "Assertion failed: result /= 19" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({8191, 123456, 127, 7});\n    if (result != 19) {\n        std::cout << "Assertion failed: result /= 19" << std::endl;\n        return 1;\n    }\n\n    result = skjkasdkd({127, 97, 8192});\n    if (result != 10) {\n        std::cout << "Assertion failed: result /= 10" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nThis C++ code mirrors the logic in the Fortran code. It contains a `main` function that performs the same tests and a `skjkasdkd` function that implements the functionality described. The `is_prime` helper function checks for prime numbers. The program will exit with a message if any test fails, otherwise, it will print "All tests passed."
Here is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n\nint multiply(int a, int b);\n\nint main() {\n    int result;\n\n    // Assertions\n    result = multiply(148, 412);\n    if (result != 16) {\n        std::cerr << "Assertion failed: multiply(148, 412) == 16" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(19, 28);\n    if (result != 72) {\n        std::cerr << "Assertion failed: multiply(19, 28) == 72" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(2020, 1851);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(2020, 1851) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(14, -15);\n    if (result != 20) {\n        std::cerr << "Assertion failed: multiply(14, -15) == 20" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(76, 67);\n    if (result != 42) {\n        std::cerr << "Assertion failed: multiply(76, 67) == 42" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(17, 27);\n    if (result != 49) {\n        std::cerr << "Assertion failed: multiply(17, 27) == 49" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 1);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 1) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    result = multiply(0, 0);\n    if (result != 0) {\n        std::cerr << "Assertion failed: multiply(0, 0) == 0" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All assertions passed!" << std::endl;\n    return 0;\n}\n\n// Function definition\nint multiply(int a, int b) {\n    return (std::abs(a) % 10) * (std::abs(b) % 10);\n}\n```\n\nIn this C++ version:\n1. The `multiply` function is defined to compute the product of the last digits of `a` and `b` using `std::abs` and the modulo operator `%`.\n2. The `main` function performs the assertions similar to the original Fortran code using `std::cerr` to print error messages and `std::exit(1)` to terminate the program in case of an assertion failure.\n3. `std::cout` is used to print a success message if all assertions pass.
Here is a C++ version of the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Function declaration\nint count_upper(const std::string &s);\n\n// Main function\nint main() {\n    int result;\n\n    // Test cases\n    result = count_upper("aBCdEf");\n    if (result != 1) {\n        std::cout << "Assertion failed: count_upper('aBCdEf') == 1" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("abcdefg");\n    if (result != 0) {\n        std::cout << "Assertion failed: count_upper('abcdefg') == 0" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("dBBE");\n    if (result != 0) {\n        std::cout << "Assertion failed: count_upper('dBBE') == 0" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("B");\n    if (result != 0) {\n        std::cout << "Assertion failed: count_upper('B') == 0" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("U");\n    if (result != 1) {\n        std::cout << "Assertion failed: count_upper('U') == 1" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("");\n    if (result != 0) {\n        std::cout << "Assertion failed: count_upper('') == 0" << std::endl;\n        return 1;\n    }\n\n    result = count_upper("EEEE");\n    if (result != 2) {\n        std::cout << "Assertion failed: count_upper('EEEE') == 2" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nint count_upper(const std::string &s) {\n    std::string uvowel = "AEIOU";\n    int count = 0;\n    size_t len_s = s.length();\n\n    for (size_t i = 0; i < len_s; i += 2) {\n        if (uvowel.find(s[i]) != std::string::npos) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```\n\nExplanation:\n1. The `count_upper` function in C++ is defined to take a `const std::string &s` as input and return the count of uppercase vowels that appear at every second position in the string, starting from the first position (0-indexed).\n\n2. In the main function, test cases are checked similarly to the Fortran code. If any test case fails, the program prints an error message and returns `1`.\n\n3. The `count_upper` function uses the `find` method of `std::string` to check if a character is a vowel.\n\n4. The loop runs with a step of 2, similar to the behavior in the Fortran code, to achieve the same results.
Below is the equivalent C++ code for the given Fortran program. The code utilizes the C++ standard library for string manipulation and input/output operations. The `closest_integer` function converts a string to a floating-point number and then to the nearest integer, while the `assert` function checks conditions and prints an error message if the condition fails.\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <sstream>\n\n// Function to get the closest integer to a given string representation of a number\nint closest_integer(const std::string& value) {\n    double w;\n    std::istringstream(value) >> w; // Convert string to double\n    return std::round(w); // Round to the nearest integer\n}\n\n// Function to assert a condition and exit the program with an error message if the assertion fails\nvoid assert_condition(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        std::exit(1); // Exit with status 1 indicating failure\n    }\n}\n\nint main() {\n    // Main program body with test cases\n    assert_condition(closest_integer("10") == 10, "Assertion failed: closest_integer('10') == 10");\n    assert_condition(closest_integer("14.5") == 15, "Assertion failed: closest_integer('14.5') == 15");\n    assert_condition(closest_integer("-15.5") == -16, "Assertion failed: closest_integer('-15.5') == -16");\n    assert_condition(closest_integer("15.3") == 15, "Assertion failed: closest_integer('15.3') == 15");\n    assert_condition(closest_integer("0") == 0, "Assertion failed: closest_integer('0') == 0");\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **closest_integer function**: \n   - This function takes a `std::string` as input, converts it to a `double` using `std::istringstream`, and then rounds it to the nearest integer using `std::round`.\n   - The return type is `int`.\n\n2. **assert_condition function**: \n   - This function takes a `bool` condition and a `std::string` message.\n   - If the condition is false, it prints the message to standard error output and exits the program with a status code of 1.\n\n3. **main function**: \n   - This function tests the `closest_integer` function with various inputs to ensure it behaves as expected, using `assert_condition` to validate the results.\n\nYou can compile this C++ code using a standard C++ compiler such as `g++`:\n\n```sh\ng++ -o main main.cpp\n```\n\nThen, run the compiled program:\n\n```sh\n./main\n```\n\nIf all assertions pass, the program will exit normally. If any assertion fails, it will print the corresponding error message and exit with a status code of 1.
Here's a C++ translation of the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nvoid make_a_pile(int n, std::vector<int>& out) {\n    out.resize(n);\n    out[0] = n;\n    for (int i = 1; i < n; ++i) {\n        out[i] = out[i - 1] + 2;\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> pile;\n    \n    make_a_pile(3, pile);\n    assert_condition(issame(pile, {3, 5, 7}));\n    \n    make_a_pile(4, pile);\n    assert_condition(issame(pile, {4, 6, 8, 10}));\n    \n    make_a_pile(5, pile);\n    assert_condition(issame(pile, {5, 7, 9, 11, 13}));\n    \n    make_a_pile(6, pile);\n    assert_condition(issame(pile, {6, 8, 10, 12, 14, 16}));\n    \n    make_a_pile(8, pile);\n    assert_condition(issame(pile, {8, 10, 12, 14, 16, 18, 20, 22}));\n    \n    return 0;\n}\n```\n\n### Explanation\n1. **Include Headers**: Use `<iostream>` for input/output operations, `<vector>` for dynamic array management, and `<cassert>` for assertions.\n2. **`make_a_pile` Function**: The function resizes the vector to `n` elements and initializes the sequence starting from `n` and increasing by 2 for each subsequent element.\n3. **`issame` Function**: This function compares two vectors for equality in size and elements.\n4. **`assert_condition` Function**: This function checks a condition and prints an error message and exits if the condition is false.\n5. **`main` Function**: This function tests the `make_a_pile` function with different values and uses assertions to verify correctness.\n\nThis code achieves the same functionality as the original Fortran program but in C++.
Sure, here's the translated C++ code from the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <cstdlib> // for exit\nusing namespace std;\n\nint choose_num(int x, int y);\n\nint main() {\n    int result;\n\n    result = choose_num(12, 15);\n    if (result != 14) {\n        cout << "Assertion failed: choose_num(12, 15) == 14" << endl;\n        exit(1);\n    }\n\n    result = choose_num(13, 12);\n    if (result != -1) {\n        cout << "Assertion failed: choose_num(13, 12) == -1" << endl;\n        exit(1);\n    }\n\n    result = choose_num(33, 12354);\n    if (result != 12354) {\n        cout << "Assertion failed: choose_num(33, 12354) == 12354" << endl;\n        exit(1);\n    }\n\n    result = choose_num(5234, 5233);\n    if (result != -1) {\n        cout << "Assertion failed: choose_num(5234, 5233) == -1" << endl;\n        exit(1);\n    }\n\n    result = choose_num(6, 29);\n    if (result != 28) {\n        cout << "Assertion failed: choose_num(6, 29) == 28" << endl;\n        exit(1);\n    }\n\n    result = choose_num(27, 10);\n    if (result != -1) {\n        cout << "Assertion failed: choose_num(27, 10) == -1" << endl;\n        exit(1);\n    }\n\n    result = choose_num(7, 7);\n    if (result != -1) {\n        cout << "Assertion failed: choose_num(7, 7) == -1" << endl;\n        exit(1);\n    }\n\n    result = choose_num(546, 546);\n    if (result != 546) {\n        cout << "Assertion failed: choose_num(546, 546) == 546" << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n\nint choose_num(int x, int y) {\n    if (y < x) {\n        return -1;\n    } else if (y == x && y % 2 == 1) {\n        return -1;\n    } else if (y % 2 == 1) {\n        return y - 1;\n    } else {\n        return y;\n    }\n}\n```\n\nThis code performs the same operations as the original Fortran program. It includes the `choose_num` function logic and tests various assertions, printing an error message and exiting the program with a non-zero status code if any of the assertions fail.
Translating the Fortran code to C++ requires several changes, including the use of correct data types, functions, and methodologies that fit C++ standards. Below is an equivalent implementation in C++:\n\n### C++ Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>  // for exit\n#include <cassert>  // for assert\n\n// Function to compute rounded average and return it as a binary string\nstd::string rounded_avg(int n, int m) {\n    if (n > m) {\n        return "-1";\n    }\n\n    int num = (m + n) / 2;\n    std::string result = "";\n\n    if (num == 0) {\n        result = "0";\n    }\n\n    while (num > 0) {\n        result = std::to_string(num % 2) + result;\n        num /= 2;\n    }\n\n    return result;\n}\n\n// Custom assert function to test conditions\nvoid custom_assert(bool condition, const std::string& message) {\n    if (!condition) {\n        std::cerr << message << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    custom_assert(rounded_avg(1, 5) == "11", "Assertion failed: rounded_avg(1, 5) == '11'");\n    custom_assert(rounded_avg(7, 13) == "1010", "Assertion failed: rounded_avg(7, 13) == '1010'");\n    custom_assert(rounded_avg(964, 977) == "1111001010", "Assertion failed: rounded_avg(964, 977) == '1111001010'");\n    custom_assert(rounded_avg(996, 997) == "1111100100", "Assertion failed: rounded_avg(996, 997) == '1111100100'");\n    custom_assert(rounded_avg(560, 851) == "1011000001", "Assertion failed: rounded_avg(560, 851) == '1011000001'");\n    custom_assert(rounded_avg(185, 546) == "101101101", "Assertion failed: rounded_avg(185, 546) == '101101101'");\n    custom_assert(rounded_avg(362, 496) == "110101101", "Assertion failed: rounded_avg(362, 496) == '110101101'");\n    custom_assert(rounded_avg(350, 902) == "1001110010", "Assertion failed: rounded_avg(350, 902) == '1001110010'");\n    custom_assert(rounded_avg(197, 233) == "11010111", "Assertion failed: rounded_avg(197, 233) == '11010111'");\n    custom_assert(rounded_avg(7, 5) == "-1", "Assertion failed: rounded_avg(7, 5) == '-1'");\n    custom_assert(rounded_avg(5, 1) == "-1", "Assertion failed: rounded_avg(5, 1) == '-1'");\n    custom_assert(rounded_avg(5, 5) == "101", "Assertion failed: rounded_avg(5, 5) == '101'");\n\n    return 0;\n}\n```\n\n### Explanation\n- **rounded_avg function**: This function calculates the rounded average and converts it to a binary string. If `n` is greater than `m`, it returns `-1`.\n- **custom_assert function**: Mimics the behavior of the Fortran `assert` subroutine by terminating the program if the condition is false and printing an error message to the standard error.\n- **main function**: Contains test cases using the `custom_assert` function to verify the correctness of the `rounded_avg` function.\n\nThis C++ version follows the same logic as the Fortran code while using C++ features and conventions.
Certainly! Here's the translation of the provided Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n// Define a struct to represent numto_type\nstruct NumtoType {\n    int key;\n    char value[10];\n};\n\n// Sorting function for the array\nvoid sort_array(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n}\n\n// Function to convert numbers to length-based string representation\nstd::vector<std::string> by_length(std::vector<int>& arr) {\n    std::vector<NumtoType> numto = {\n        {0, "Zero"}, {1, "One"}, {2, "Two"}, {3, "Three"},\n        {4, "Four"}, {5, "Five"}, {6, "Six"}, {7, "Seven"},\n        {8, "Eight"}, {9, "Nine"}\n    };\n\n    sort_array(arr);\n\n    std::vector<std::string> out;\n    for (auto it = arr.rbegin(); it != arr.rend(); ++it) {\n        if (*it >= 1 && *it <= 9) {\n            out.push_back(std::string(numto[*it].value));\n        }\n    }\n    return out;\n}\n\n// Function to compare two arrays of strings\nbool issame(const std::vector<std::string>& a, const std::vector<std::string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> expected1 = {"Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"};\n    std::vector<std::string> expected2 = {"One"};\n    std::vector<std::string> expected3 = {"Three", "Two", "One"};\n    std::vector<std::string> expected4 = {"Nine", "Eight", "Four"};\n\n    std::vector<int> arr;\n\n    arr = {2, 1, 1, 4, 5, 8, 2, 3};\n    auto result = by_length(arr);\n    if (!issame(result, expected1)) {\n        std::cout << "Test 1: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr.clear();\n    result = by_length(arr);\n    if (!issame(result, expected2)) {\n        std::cout << "Test 2: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 55};\n    result = by_length(arr);\n    if (!issame(result, expected2)) {\n        std::cout << "Test 3: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {1, -1, 3, 2};\n    result = by_length(arr);\n    if (!issame(result, expected3)) {\n        std::cout << "Test 4: assertion failed" << std::endl;\n        return 1;\n    }\n\n    arr = {9, 4, 8};\n    result = by_length(arr);\n    if (!issame(result, expected4)) {\n        std::cout << "Test 5: assertion failed" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **Struct Definition (`NumtoType`)**:\n   - The `NumtoType` struct is used to store the key-value pairs similar to the Fortran `type` definition.\n\n2. **Sorting Function (`sort_array`)**:\n   - This function sorts the array in ascending order, leveraging C++'s `std::sort` from the `<algorithm>` library.\n\n3. **Conversion Function (`by_length`)**:\n   - This function sorts the array and converts integers 1 through 9 to their respective string representations.\n   - It utilizes a vector of `NumtoType` and checks if elements fall within the range 1 to 9, appending the corresponding string representation to the output vector.\n\n4. **Comparison Function (`issame`)**:\n   - This function checks if two vectors of strings are identical in terms of size and content, akin to comparing arrays in Fortran.\n\n5. **Main Function (`main`)**:\n   - This function performs the test cases, similar to the `program main` part in Fortran. It verifies transformed outputs against expected values using the `issame` function and prints appropriate messages based on the test results.\n\nThe provided C++ code maintains similar functionality and behavior as the Fortran code, conforming to C++'s syntax and idioms.
Sure, here's the equivalent C++ code:\n\n```c++\n#include <iostream>\n#include <vector>\n#include <cstdlib> // for std::exit\n\nstd::vector<int> f(int n) {\n    std::vector<int> out(n);\n    int sum = 0;\n    int prod = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) {\n            out[i-1] = prod; // C++ indices start at 0\n        } else {\n            out[i-1] = sum;\n        }\n    }\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> expected1 = {1, 2, 6, 24, 15};\n    std::vector<int> expected2 = {1, 2, 6, 24, 15, 720, 28};\n    std::vector<int> expected3 = {1};\n    std::vector<int> expected4 = {1, 2, 6};\n\n    std::vector<int> result;\n\n    result = f(5);\n    if (!issame(result, expected1)) {\n        std::cout << "Assertion failed for f(5)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(7);\n    if (!issame(result, expected2)) {\n        std::cout << "Assertion failed for f(7)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(1);\n    if (!issame(result, expected3)) {\n        std::cout << "Assertion failed for f(1)" << std::endl;\n        std::exit(1);\n    }\n\n    result = f(3);\n    if (!issame(result, expected4)) {\n        std::cout << "Assertion failed for f(3)" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed" << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n- The `f` function creates a vector `out` of size `n` and calculates the sum and product similarly to the Fortran code.\n- The `issame` function checks if two vectors are the same by comparing their sizes and then their elements.\n- The `main` function tests the `f` function against the expected results and prints an appropriate message. If any test fails, the program prints an assertion failed message and exits with status `1`. If all tests pass, it prints "All tests passed".
Here is the translated C++ version of your Fortran code. Note that C++ has some differences in syntax and style, so the translation aims to maintain the primary logic and structure while adapting to idiomatic C++ practices.\n\n```cpp\n#include <iostream>\n#include <array>\n#include <string>\n#include <cstdlib>\n\nstd::array<int, 2> even_odd_palindrome(int n);\nstd::string reverse_string(const std::string &s);\nbool issame(const std::array<int, 2> &a, const std::array<int, 2> &b);\nvoid test_even_odd_palindrome(int n, const std::array<int, 2> &expected);\n\nint main() {\n    // Test cases\n    test_even_odd_palindrome(123, {8, 13});\n    test_even_odd_palindrome(12, {4, 6});\n    test_even_odd_palindrome(3, {1, 2});\n    test_even_odd_palindrome(63, {6, 8});\n    test_even_odd_palindrome(25, {5, 6});\n    test_even_odd_palindrome(19, {4, 6});\n    test_even_odd_palindrome(9, {4, 5});\n    test_even_odd_palindrome(1, {0, 1});\n\n    return 0;\n}\n\nvoid test_even_odd_palindrome(int n, const std::array<int, 2> &expected) {\n    std::array<int, 2> result = even_odd_palindrome(n);\n\n    if (!issame(result, expected)) {\n        std::cout << "Assertion failed for n = " << n << std::endl;\n        exit(1);\n    }\n}\n\nstd::array<int, 2> even_odd_palindrome(int n) {\n    std::array<int, 2> res = {0, 0};\n    int num1 = 0;\n    int num2 = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        std::string w = std::to_string(i);\n        std::string p = reverse_string(w);\n\n        if (w == p) {\n            if (i % 2 == 1) {\n                num1++;\n            } else {\n                num2++;\n            }\n        }\n    }\n    res = {num2, num1};\n    return res;\n}\n\nstd::string reverse_string(const std::string &s) {\n    return std::string(s.rbegin(), s.rend());\n}\n\nbool issame(const std::array<int, 2> &a, const std::array<int, 2> &b) {\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\nHere are a few points to note about this translation:\n1. **C++ Standard Library Usage**: We use `std::array` for the fixed-size array and `std::string` for strings and reversing them.\n2. **Testing with `main` Function**: The `main` function drives the test cases.\n3. **Iterating over Numbers**: We iterate over integers and check if their string representations are palindromes using standard string operations.\n4. **Function Translation**: The logic in Fortran subroutines and functions are translated to C++ functions.\n\nThis translation keeps the core logic of the Fortran code while making use of C++ standard library features.
Below is the Fortran code translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\n\nint count_nums(const std::vector<int>& n) {\n    int num = 0;\n    \n    for (int i = 0; i < n.size(); ++i) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = std::abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w /= 10;\n            }\n            sum -= w;\n            if (sum > 0)\n                num += 1;\n        }\n    }\n    \n    return num;\n}\n\nvoid assert_equal(int result, int expected, const std::string& test_case) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << test_case << " == " << expected << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Define the test cases and expected results\n    std::vector<std::pair<std::vector<int>, int>> test_cases = {\n        {{0}, 0},\n        {{-1, -2, 0}, 0},\n        {{1, 1, 2, -2, 3, 4, 5}, 6},\n        {{1, 6, 9, -6, 0, 1, 5}, 5},\n        {{1, 100, 98, -7, 1, -1}, 4},\n        {{12, 23, 34, -45, -56, 0}, 5},\n        {{-0, 1}, 1},\n        {{1}, 1}\n    };\n\n    // Run the tests\n    for (const auto& test_case : test_cases) {\n        int result = count_nums(test_case.first);\n        assert_equal(result, test_case.second, "count_nums(" + std::to_string(test_case.first.size()) + ")");\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    \n    return 0;\n}\n```\n\nExplanation:\n1. **count_nums function**: The Fortran function `count_nums` is translated to a C++ function taking a `std::vector<int>` as input and returning an integer.\n2. **assert_equal function**: This helper function ensures that the result of `count_nums` matches the expected value for each input, similar to the if-conditions in the Fortran code.\n3. **main function**: The main function sets up test cases as a `std::vector` of pairs, where each pair consists of a vector of integers and the expected result. Each test case is processed by `count_nums`, and the result is validated using `assert_equal`.\n\nThe logic within `count_nums` is the same as in the Fortran function, following equivalent operations for sums and loop control. The tests at the end of `main` validate the function against predefined scenarios.
Here's how you can translate the Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nbool move_one_ball(const std::vector<int>& arr) {\n    int num = 0;\n\n    if (arr.empty()) {\n        return true;\n    }\n\n    for (std::size_t i = 1; i < arr.size(); ++i) {\n        if (arr[i] < arr[i - 1]) {\n            num++;\n        }\n    }\n\n    if (arr.back() > arr.front()) {\n        num++;\n    }\n\n    return (num < 2);\n}\n\nint main() {\n    std::vector<std::vector<int>> testCases = {\n        {3, 4, 5, 1, 2},\n        {3, 5, 10, 1, 2},\n        {4, 3, 1, 2},\n        {3, 5, 4, 1, 2},\n        {}\n    };\n\n    for (const auto& arr : testCases) {\n        bool result = move_one_ball(arr);\n        if (arr == std::vector<int>{3, 4, 5, 1, 2} && !result) {\n            std::cerr << "Assertion failed for {3, 4, 5, 1, 2}" << std::endl;\n            return 1;\n        }\n        if (arr == std::vector<int>{3, 5, 10, 1, 2} && !result) {\n            std::cerr << "Assertion failed for {3, 5, 10, 1, 2}" << std::endl;\n            return 1;\n        }\n        if (arr == std::vector<int>{4, 3, 1, 2} && result) {\n            std::cerr << "Assertion failed for {4, 3, 1, 2}" << std::endl;\n            return 1;\n        }\n        if (arr == std::vector<int>{3, 5, 4, 1, 2} && result) {\n            std::cerr << "Assertion failed for {3, 5, 4, 1, 2}" << std::endl;\n            return 1;\n        }\n        if (arr.empty() && !result) {\n            std::cerr << "Assertion failed for {}" << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definition:**\n    - The `move_one_ball` function in C++ takes a `std::vector<int>` as input and returns a boolean value, similar to the Fortran function.\n\n2. **Check for Empty Array:**\n    - The equivalent check for an empty array is `if (arr.empty())`.\n\n3. **Loop Through Array:**\n    - The Fortran loop from 2 to `size(arr)` is translated to a C++ for loop starting from 1 to `arr.size() - 1`.\n\n4. **Comparisons and Counting:**\n    - We replicate the condition checks and increment the `num` variable in the loop.\n\n5. **Final Condition Check:**\n    - The condition where we compare the first and last elements of the array is directly translated.\n\n6. **Main Function and Test Cases:**\n    - The main function in C++ initializes test cases using `std::vector` and uses assertions to validate the function's correctness.\n    - The `cerr` stream is used to output assertion failures, and tests are passed if no failure messages are printed.\n\nThis code translates the logical flow of your Fortran program into equivalent C++ constructs using standard libraries and idiomatic C++ code patterns.
Certainly! Below is the translated C++ code that corresponds to the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nstd::string exchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int num = 0;\n\n    for (const auto& val : lst1) {\n        if (val % 2 == 0) num++;\n    }\n\n    for (const auto& val : lst2) {\n        if (val % 2 == 0) num++;\n    }\n\n    if (num >= lst1.size()) {\n        return "YES";\n    } else {\n        return "NO";\n    }\n}\n\nint main() {\n    std::string result;\n\n    result = exchange({1, 2, 3, 4}, {1, 2, 3, 4});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 2, 3, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({1, 2, 3, 4}, {1, 5, 3, 4});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {1, 5, 3, 4}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({1, 2, 3, 4}, {2, 1, 4, 3});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({1, 2, 3, 4}, {2, 1, 4, 3}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({5, 7, 3}, {2, 6, 4});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 4}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({5, 7, 3}, {2, 6, 3});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({5, 7, 3}, {2, 6, 3}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: exchange({3, 2, 6, 1, 8, 9}, {3, 5, 5, 1, 1, 1}) == 'NO'" << std::endl;\n        std::exit(1);\n    }\n\n    result = exchange({100, 200}, {200, 200});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: exchange({100, 200}, {200, 200}) == 'YES'" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code does the same as the provided Fortran code: it checks if a given number of even numbers in two lists meet a certain condition and performs unit tests to verify the function's behavior.
Translating the provided Fortran code to C++ involves several steps due to the different ways the two languages handle arrays, strings, memory allocation, and I/O operations. Here is an equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvoid odd_count(const vector<string>& lst, vector<string>& out);\nvoid print_results(const vector<string>& output, const vector<string>& expected);\nbool issame(const vector<string>& a, const vector<string>& b);\nvoid assert(bool condition);\n\n// Utility function to count odd digits in a string\nint count_odd_digits(const string& s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isdigit(c) && (c - '0') % 2 != 0) {\n            sum++;\n        }\n    }\n    return sum;\n}\n\n// Function to replace 'i' in the string with the given integer value\nstring replace_i_with_sum(const string& s, int sum) {\n    string result;\n    for (char c : s) {\n        if (c == 'i') {\n            result += to_string(sum);\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<string> input, output, expected;\n\n    // Test case 1\n    input = {"1234567"};\n    expected = {"the number of odd elements 4n the str4ng 4 of the 4nput."};\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 2\n    input = {"3", "11111111"};\n    expected = {\n        "the number of odd elements 1n the str1ng 1 of the 1nput.",\n        "the number of odd elements 8n the str8ng 8 of the 8nput."\n    };\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    // Test case 3\n    input = {"271", "137", "314"};\n    expected = {\n        "the number of odd elements 2n the str2ng 2 of the 2nput.",\n        "the number of odd elements 3n the str3ng 3 of the 3nput.",\n        "the number of odd elements 2n the str2ng 2 of the 2nput."\n    };\n    odd_count(input, output);\n    print_results(output, expected);\n    assert(issame(output, expected));\n\n    return 0;\n}\n\nvoid odd_count(const vector<string>& lst, vector<string>& out) {\n    out.clear();\n    string template_str = "the number of odd elements in the string i of the input.";\n    \n    for (const string& s : lst) {\n        int sum = count_odd_digits(s);\n        string modified_str = replace_i_with_sum(template_str, sum);\n        out.push_back(modified_str);\n    }\n}\n\nbool issame(const vector<string>& a, const vector<string>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i].compare(b[i]) != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        cout << "Assertion failed" << endl;\n        exit(1); // Exit with a failure code\n    }\n}\n\nvoid print_results(const vector<string>& output, const vector<string>& expected) {\n    cout << "Actual Output:\n";\n    for (const string& s : output) {\n        cout << s << endl;\n    }\n    cout << "Expected Output:\n";\n    for (const string& s : expected) {\n        cout << s << endl;\n    }\n}\n```\n\n### Notes:\n1. **Memory Management:** C++ handles memory allocation and deallocation automatically with STL containers like `vector`.\n2. **String Manipulation:** The code uses C++ standard library functions for string manipulation.\n3. **Functions:** The C++ functions `odd_count`, `issame`, `assert`, and `print_results` perform the roles of their Fortran counterparts.\n4. **Main Function:** The main logic demonstrates how to set up test cases, call functions, and check results.
Sure, I'll convert the provided Fortran code to C++. Here's the equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\nstd::vector<int> sort_array(const std::vector<int>& arr) {\n    std::vector<int> sorted_arr(arr);\n    std::vector<int> bin(arr.size());\n\n    // Calculate the number of 1s in the binary representation of each element\n    for (size_t i = 0; i < arr.size(); ++i) {\n        int b = 0;\n        int n = std::abs(arr[i]);\n        while (n > 0) {\n            b += n % 2;\n            n /= 2;\n        }\n        bin[i] = b;\n    }\n\n    // Sort the array based on the bin values and the original values\n    for (size_t i = 0; i < arr.size(); ++i) {\n        for (size_t j = 1; j < arr.size(); ++j) {\n            if (bin[j] < bin[j-1] || (bin[j] == bin[j-1] && sorted_arr[j] < sorted_arr[j-1])) {\n                std::swap(sorted_arr[j], sorted_arr[j-1]);\n                std::swap(bin[j], bin[j-1]);\n            }\n        }\n    }\n\n    return sorted_arr;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid test_case(const std::vector<int>& arr, const std::vector<int>& expected) {\n    std::vector<int> sorted_arr = sort_array(arr);\n    if (!issame(sorted_arr, expected)) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);  // Exit the program with a failure status\n    }\n}\n\nvoid run_tests() {\n    // Test cases\n    test_case({1, 5, 2, 3, 4}, {1, 2, 4, 3, 5});\n    test_case({-2, -3, -4, -5, -6}, {-4, -2, -6, -5, -3});\n    test_case({1, 0, 2, 3, 4}, {0, 1, 2, 4, 3});\n    test_case({2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4}, {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77});\n    test_case({3, 6, 44, 12, 32, 5}, {32, 3, 5, 6, 12, 44});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n    test_case({2, 4, 8, 16, 32}, {2, 4, 8, 16, 32});\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nHere's a brief explanation of the changes made during the translation:\n\n1. **Function Definitions**: The Fortran subroutines and functions have been converted into C++ functions.\n2. **Vector and Dynamic Arrays**: The Fortran arrays have been replaced with C++ `std::vector`, which provides similar dynamic array behavior.\n3. **Error Handling**: The Fortran `write(*,*)` statement and `call exit(1)` have been replaced with `std::cerr` for error output and `std::exit(1)` to exit the program upon assertion failure.\n4. **Swapping Elements**: The swapping operation in the sorting step uses `std::swap` for convenience.\n\nThis C++ code maintains the original structure and logic of the Fortran program while adhering to C++ syntax and idioms.
To translate the given Fortran code to C++, you need to consider several aspects such as type declarations, loops, and function return types. Here is a translation of your Fortran program into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cassert>\n\nstd::string get_closest_vowel(const std::string& word) {\n    const std::string vowels = "AEIOUaeiou";\n    std::string out = "";\n\n    for (int i = word.size() - 2; i > 0; --i) {\n        if (vowels.find(word[i]) != std::string::npos) {\n            if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos) {\n                out = word[i];\n                return out;\n            }\n        }\n    }\n    return out;\n}\n\nvoid test() {\n    assert(get_closest_vowel("yogurt") == "u");\n    assert(get_closest_vowel("full") == "u");\n    assert(get_closest_vowel("easy") == "");\n    assert(get_closest_vowel("eAsy") == "");\n    assert(get_closest_vowel("ali") == "");\n    assert(get_closest_vowel("bad") == "a");\n    assert(get_closest_vowel("most") == "o");\n    assert(get_closest_vowel("ab") == "");\n    assert(get_closest_vowel("ba") == "");\n    assert(get_closest_vowel("quick") == "");\n    assert(get_closest_vowel("anime") == "i");\n    assert(get_closest_vowel("Asia") == "");\n    assert(get_closest_vowel("Above") == "o");\n\n    std::cout << "All test cases passed!" << std::endl;\n}\n\nint main() {\n    test();\n    return 0;\n}\n```\n\n### Explanation:\n1. **`#include <iostream>` and `#include <string>`**: These headers are included for I/O operations and to use the `std::string` class.\n2. **`std::string get_closest_vowel(const std::string& word)`**: This function takes a `std::string` as input and returns the closest vowel following the same logic as the Fortran code.\n3. **`std::string vowels = "AEIOUaeiou";`**: This defines the set of vowels.\n4. **`for` loop**: Iterates through the string `word` in reverse order, checking each character.\n   - **`if (vowels.find(word[i]) != std::string::npos)`**: Checks if `word[i]` is a vowel.\n   - **`if (vowels.find(word[i + 1]) == std::string::npos && vowels.find(word[i - 1]) == std::string::npos)`**: Checks that both the previous and next characters are not vowels.\n5. **`void test()`**: This function includes all the assertions to test `get_closest_vowel` and ensures that all test cases are validated.\n6. **`int main()`**: The main function calls the `test()` function and returns 0, indicating successful execution.\n\nThis C++ program mirrors the logic and functional components of the original Fortran code. Run the code using a C++ compiler to confirm that it works as expected.
Here's the equivalent C++ code for the provided Fortran program. The C++ code uses standard library functions and vectors to achieve similar functionality:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nvoid bubble_sort(std::vector<int>& arr) {\n    for (size_t i = 0; i < arr.size() - 1; i++) {\n        for (size_t j = 0; j < arr.size() - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n            }\n        }\n    }\n}\n\nstd::vector<int> maximum(const std::vector<int>& arr, int k) {\n    std::vector<int> sorted_arr = arr;\n    bubble_sort(sorted_arr); // Sort array\n    std::vector<int> out(sorted_arr.end() - k, sorted_arr.end());\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    \n    for (size_t i = 0; i < a.size(); i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nvoid run_tests() {\n    assert(issame(maximum({-3, -4, 5}, 3), {-4, -3, 5}));\n    assert(issame(maximum({4, -4, 4}, 2), {4, 4}));\n    assert(issame(maximum({-3, 2, 1, 2, -1, -2, 1}, 1), {2}));\n    assert(issame(maximum({123, -123, 20, 0, 1, 2, -3}, 3), {2, 20, 123}));\n    assert(issame(maximum({-123, 20, 0, 1, 2, -3}, 4), {0, 1, 2, 20}));\n    assert(issame(maximum({5, 15, 0, 3, -13, -8, 0}, 7), {-13, -8, 0, 0, 3, 5, 15}));\n    assert(issame(maximum({-1, 0, 2, 5, 3, -10}, 2), {3, 5}));\n    assert(issame(maximum({1, 0, 5, -7}, 1), {5}));\n    assert(issame(maximum({4, -4}, 2), {-4, 4}));\n    assert(issame(maximum({-10, 10}, 2), {-10, 10}));\n    assert(issame(maximum({1, 2, 3, -23, 243, -400, 0}, 0), {}));\n}\n\nint main() {\n    run_tests();\n    std::cout << "All tests passed.\n";\n    return 0;\n}\n```\n\nKey points regarding the translation:\n1. The Fortran arrays have been translated to C++ `std::vector<int>`, which allows dynamic resizing and easy element access.\n2. The bubble sort and maximum functions have direct counterparts in C++.\n3. The `issame` function checks for vector equality.\n4. The `run_tests` function uses the `assert` function from the C++ standard library to verify that the program behaves as expected.
Here's the equivalent C++ code for the provided Fortran program.\n\n```c++\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n// Function to calculate the sum of odd-indexed odd elements\nint solutions(const std::vector<int>& lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) { // C++ index starts from 0, equivalent to odd indices in Fortran\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n\n#define ASSERT_EQUAL(x, y) if ((x) != (y)) { std::cerr << "Assertion failed: solutions" << x << " == " << y << std::endl; std::exit(1); }\n\nint main() {\n    // Test cases\n    ASSERT_EQUAL(solutions({5, 8, 7, 1}), 12);\n    ASSERT_EQUAL(solutions({3, 3, 3, 3, 3}), 9);\n    ASSERT_EQUAL(solutions({30, 13, 24, 321}), 0);\n    ASSERT_EQUAL(solutions({5, 9}), 5);\n    ASSERT_EQUAL(solutions({2, 4, 8}), 0);\n    ASSERT_EQUAL(solutions({30, 13, 23, 32}), 23);\n    ASSERT_EQUAL(solutions({3, 13, 2, 9}), 3);\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definition**:\n    - The `solutions` function accepts a `std::vector<int>` and calculates the sum of elements at odd indices that are odd.\n    - Note that C++ indexing starts from 0, so the for loop increments by 2 to achieve a similar effect as Fortran's 1-based indexing for odd indices.\n\n2. **Assertions**:\n    - I used the `ASSERT_EQUAL` macro to check if the actual result matches the expected result. If the assertion fails, it prints an error message and exits the program.\n\n3. **Testing**:\n    - Each test case is checked against the expected result to ensure that the function behaves as expected.\n\n4. **Output**:\n    - After all test cases pass, the program prints "All tests passed."\n\nThis C++ code should behave similarly to the provided Fortran code and produce the same results.
Certainly! Below is your Fortran code translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function to add elements of an array based on given constraints\nint add_elements(const std::vector<int>& arr, int k) {\n    int sum = 0;\n\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    // Test cases\n    assert(add_elements({1, -2, -3, 41, 57, 76, 87, 88, 99}, 3) == -4);\n    assert(add_elements({111, 121, 3, 4000, 5, 6}, 2) == 0);\n    assert(add_elements({11, 21, 3, 90, 5, 6, 7, 8, 9}, 4) == 125);\n    assert(add_elements({111, 21, 3, 4000, 5, 6, 7, 8, 9}, 4) == 24);\n    assert(add_elements({1}, 1) == 1);\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nExplanation:\n\n1. **Include necessary headers**:\n   - `#include <iostream>` for input/output operations.\n   - `#include <vector>` for the vector container.\n   - `#include <cassert>` for assertion testing.\n   \n2. **Function `add_elements`**:\n   - Takes a `const std::vector<int>&` for the array and an `int` for `k`.\n   - Initializes `sum` to 0.\n   - Loops through the first `k` elements of the array checking if each element is between -99 and 99 inclusive.\n   - Adds the qualifying elements to `sum`.\n   - Returns `sum`.\n\n3. **`main` Function**:\n   - Contains several test cases using `assert` to ensure the function `add_elements` returns expected results.\n   - Prints "All tests passed." if all assertions are true.\n\nRemember, `assert` will stop the program and display an error message if the condition is false, which simulates the Fortran `if` checks and `exit` calls.
Translating Fortran code to C++ involves several steps, including handling dynamic arrays, translating the control flow, and ensuring proper function interfaces and memory management. Below is a translated C++ version of the given Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nvoid test_odd_collatz(int n, const std::vector<int>& expected);\nstd::vector<int> get_odd_collatz(int n);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\nvoid sort(std::vector<int>& array);\n\nint main() {\n    // Test cases\n    test_odd_collatz(14, {1, 5, 7, 11, 13, 17});\n    test_odd_collatz(5, {1, 5});\n    test_odd_collatz(12, {1, 3, 5});\n    test_odd_collatz(1, {1});\n\n    return 0;\n}\n\nvoid test_odd_collatz(int n, const std::vector<int>& expected) {\n    std::vector<int> result = get_odd_collatz(n);\n    bool is_same = issame(result, expected);\n    if (!is_same) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(1);\n    }\n}\n\nstd::vector<int> get_odd_collatz(int n) {\n    std::vector<int> out;\n    out.push_back(1);\n    \n    int temp = n;\n    \n    while (temp != 1) {\n        if (temp % 2 == 1) {\n            out.push_back(temp);\n            temp = temp * 3 + 1;\n        } else {\n            temp = temp / 2;\n        }\n    }\n    \n    sort(out);\n    return out;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid sort(std::vector<int>& array) {\n    std::sort(array.begin(), array.end());\n}\n```\n\n### Explanation:\n\n1. **Include Necessary Libraries:**\n    - `<iostream>`: For input-output operations.\n    - `<vector>`: For dynamic array handling.\n    - `<algorithm>`: For the `std::sort` function to sort vectors.\n\n2. **Main Function:**\n    - In C++, the main function is `int main()`.\n    - The test cases are written inside the main function and use the `test_odd_collatz` function.\n\n3. **Test Function (`test_odd_collatz`):**\n    - Takes an integer `n` and a vector of integers `expected`.\n    - Computes the odd Collatz sequence and checks it against the expected result.\n\n4. **Collatz Function (`get_odd_collatz`):**\n    - Computes the odd terms in the Collatz sequence.\n    - Stores the terms in a vector and returns it after sorting.\n\n5. **Equality Check Function (`issame`):**\n    - Checks if two vectors are the same.\n\n6. **Sort Function (`sort`):**\n    - Sorts the vector using `std::sort` from the `<algorithm>` library.\n\nBy following this structure, you can translate the Fortran program to C++ while maintaining its functionality and ensuring proper memory management and logic flow.
Sure, here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <iomanip>\n\nbool valid_date(const std::string& date);\nvoid assert_condition(bool condition);\nstd::string pad(const std::string& str);\n\nint main() {\n    // Test cases\n    assert_condition(valid_date(pad("03-11-2000")) == true);\n    assert_condition(valid_date(pad("15-01-2012")) == false);\n    assert_condition(valid_date(pad("04-0-2040")) == false);\n    assert_condition(valid_date(pad("06-04-2020")) == true);\n    assert_condition(valid_date(pad("01-01-2007")) == true);\n    assert_condition(valid_date(pad("03-32-2011")) == false);\n    assert_condition(valid_date(pad("")) == false);\n    assert_condition(valid_date(pad("04-31-3000")) == false);\n    assert_condition(valid_date(pad("06-06-2005")) == true);\n    assert_condition(valid_date(pad("21-31-2000")) == false);\n    assert_condition(valid_date(pad("04-12-2003")) == true);\n    assert_condition(valid_date(pad("04122003")) == false);\n    assert_condition(valid_date(pad("20030412")) == false);\n    assert_condition(valid_date(pad("2003-04")) == false);\n    assert_condition(valid_date(pad("2003-04-12")) == false);\n    assert_condition(valid_date(pad("04-2003")) == false);\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n\nbool valid_date(const std::string& date) {\n    if (date.length() != 10) {\n        return false;\n    }\n\n    for (size_t i = 0; i < 10; ++i) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') {\n                return false;\n            }\n        } else if (!isdigit(date[i])) {\n            return false;\n        }\n    }\n\n    int mm = std::stoi(date.substr(0, 2));\n    int dd = std::stoi(date.substr(3, 2));\n    int yy = std::stoi(date.substr(6, 4));\n\n    if (mm < 1 || mm > 12) {\n        return false;\n    }\n\n    if (dd < 1 || dd > 31) {\n        return false;\n    }\n\n    if (dd == 31 && (mm == 4 || mm == 6 || mm == 9 || mm == 11 || mm == 2)) {\n        return false;\n    }\n\n    if (dd == 30 && mm == 2) {\n        return false;\n    }\n\n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed\n";\n        std::exit(1);\n    }\n}\n\nstd::string pad(const std::string& str) {\n    std::string padded_str = str;\n    padded_str.resize(10, ' '); // Pad with spaces up to length 10\n    return padded_str;\n}\n```\n\n### Explanation:\n1. **Main Function**:\n   - Runs a series of tests using `assert_condition` to check if `valid_date` function works correctly.\n\n2. **valid_date Function**:\n   - Checks if the provided date string follows the expected "MM-DD-YYYY" format.\n   - Ensures the correct placement of dashes ('-').\n   - Validates the numeric ranges for month (`mm`), day (`dd`), and year (`yy`) values.\n\n3. **assert_condition Function**:\n   - Prints an error message and exits the program if the condition is false.\n\n4. **pad Function**:\n   - Ensures that the date string is always 10 characters long by padding with spaces if necessary.\n\nThis C++ program performs similar operations and validations as the original Fortran code, ensuring compatibility with Fortran's fixed length character handling.
Here is the Fortran program translated into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\n// Function to check if the list is sorted\nbool is_sorted(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i - 1]) {\n            return false;\n        }\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to run tests\nvoid run_tests() {\n    std::vector<int> lst;\n\n    lst = {5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 4, 5, 6};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4, 5, 6, 7};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 3, 2, 4, 5, 6, 7};\n    assert(is_sorted(lst) == false);\n\n    lst.clear();\n    assert(is_sorted(lst) == true);\n\n    lst = {1};\n    assert(is_sorted(lst) == true);\n\n    lst = {3, 2, 1};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 2, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 3, 3, 3, 4};\n    assert(is_sorted(lst) == false);\n\n    lst = {1, 2, 2, 3, 3, 4};\n    assert(is_sorted(lst) == true);\n\n    lst = {1, 2, 3, 4};\n    assert(is_sorted(lst) == true);\n}\n\n// Main function\nint main() {\n    run_tests();\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n1. **is_sorted function**: Checks if a list is sorted and meets the criteria specified.\n2. **run_tests function**: Contains various test cases to validate the `is_sorted` function.\n3. **main function**: Simply calls `run_tests` and prints a success message if all assertions pass.\n\n### Key Differences from Fortran:\n- Memory allocation and deallocation are managed automatically via the `std::vector` in C++.\n- Assertions are done using the `assert` function from the `<cassert>` library.\n- Fortran-specific constructs like `call` and `.eqv.` are replaced by equivalent C++ constructs.\n- The structure and syntax were adapted to fit C++ standards and idioms.
Here is the equivalent C++ translation of the provided Fortran code. The code includes the main test driver and the `intersection` function:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n\n// Function declaration\nstd::string intersection(int interval1[2], int interval2[2]);\n\nint main() {\n    std::string result;\n\n    result = intersection({1, 2}, {2, 3});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({1, 2}, {2, 3}) == 'NO'\n";\n        return 1;\n    }\n\n    result = intersection({-1, 1}, {0, 4});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({-1, 1}, {0, 4}) == 'NO'\n";\n        return 1;\n    }\n\n    result = intersection({-3, -1}, {-5, 5});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection({-3, -1}, {-5, 5}) == 'YES'\n";\n        return 1;\n    }\n\n    result = intersection({-2, 2}, {-4, 0});\n    if (result != "YES") {\n        std::cerr << "Assertion failed: intersection({-2, 2}, {-4, 0}) == 'YES'\n";\n        return 1;\n    }\n\n    result = intersection({-11, 2}, {-1, -1});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({-11, 2}, {-1, -1}) == 'NO'\n";\n        return 1;\n    }\n\n    result = intersection({1, 2}, {3, 5});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({1, 2}, {3, 5}) == 'NO'\n";\n        return 1;\n    }\n\n    result = intersection({1, 2}, {1, 2});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({1, 2}, {1, 2}) == 'NO'\n";\n        return 1;\n    }\n\n    result = intersection({-2, -2}, {-3, -2});\n    if (result != "NO") {\n        std::cerr << "Assertion failed: intersection({-2, -2}, {-3, -2}) == 'NO'\n";\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nstd::string intersection(int interval1[2], int interval2[2]) {\n    int inter1 = std::max(interval1[0], interval2[0]);\n    int inter2 = std::min(interval1[1], interval2[1]);\n    int l = inter2 - inter1;\n\n    if (l < 2) {\n        return "NO";\n    }\n\n    for (int i = 2; i <= static_cast<int>(std::sqrt(l)); ++i) {\n        if (l % i == 0) {\n            return "NO";\n        }\n    }\n\n    return "YES";\n}\n```\n\n### Explanation:\n\n1. **Function Signature and Main Function**:\n    - The C++ function `intersection` has the same functionality as the Fortran function. It takes two integer arrays and returns a string.\n    - The main function contains the test cases that you provided in the Fortran code.\n\n2. **Intersection Logic**:\n    - The `intersection` function computes the largest starting point of the two intervals and the smallest ending point.\n    - It then checks if the length of the intersection is less than 2.\n    - If the length is at least 2, the function checks if this length is a prime number using the standard trial division method up to the square root of the length.\n    - If any divisor is found, it returns `"NO"`, otherwise, it returns `"YES"`.\n\n3. **Test Cases**:\n    - The test cases directly check the result and print an error message if the expected value is not matched.\n\n4. **Standard Libraries**:\n    - `<iostream>` for standard I/O operations.\n    - `<cmath>` for the `sqrt` function.\n    - `<cstdlib>` for the `exit` function, but in this version, I've used the `return` statement from main instead.\n    - `<algorithm>` for the `std::max` and `std::min` functions.\n\nLet me know if you need any further adjustments or explanations!
Certainly! Here is the corresponding C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <numeric>\n#include <cmath>\n\n// Function to calculate the product of signs and the sum of absolute values\nint prod_signs(const std::vector<int>& arr) {\n    if (arr.empty() || (arr.size() == 1 && arr[0] == 0)) {\n        return -32768;\n    }\n\n    int sum = 0;\n    int prods = 1;\n\n    for (int val : arr) {\n        sum += std::abs(val);\n        if (val == 0) {\n            prods = 0;\n        }\n        if (val < 0) {\n            prods = -prods;\n        }\n    }\n\n    return sum * prods;\n}\n\n// Function to test assertions\nvoid assert_equal(int result, int expected, const std::string& message) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << message << "\n";\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    assert_equal(prod_signs({1, 2, 2, -4}), -9, "prod_signs([1, 2, 2, -4]) == -9");\n    assert_equal(prod_signs({0, 1}), 0, "prod_signs([0, 1]) == 0");\n    assert_equal(prod_signs({1, 1, 1, 2, 3, -1, 1}), -10, "prod_signs([1, 1, 1, 2, 3, -1, 1]) == -10");\n    assert_equal(prod_signs({0}), -32768, "prod_signs([]) == -32768");\n    assert_equal(prod_signs({2, 4, 1, 2, -1, -1, 9}), 20, "prod_signs([2, 4, 1, 2, -1, -1, 9]) == 20");\n    assert_equal(prod_signs({-1, 1, -1, 1}), 4, "prod_signs([-1, 1, -1, 1]) == 4");\n    assert_equal(prod_signs({-1, 1, 1, 1}), -4, "prod_signs([-1, 1, 1, 1]) == -4");\n    assert_equal(prod_signs({-1, 1, 1, 0}), 0, "prod_signs([-1, 1, 1, 0]) == 0");\n\n    std::cout << "All tests passed.\n";\n    \n    return 0;\n}\n```\n\nThis C++ code includes:\n\n1. The `prod_signs` function, which calculates the product of signs and the sum of absolute values for the input vector `arr`.\n2. The `assert_equal` function to check if the result matches the expected value and to print an error message and exit if the assertion fails.\n3. The `main` function to run all test cases and verify the correctness of the `prod_signs` function.
Here's the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\n\n// Helper function to reshape a 1D array into a 2D vector\nvector<vector<int>> reshape(const vector<int>& data, int rows, int cols) {\n    vector<vector<int>> reshaped(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i)\n        for (int j = 0; j < cols; ++j)\n            reshaped[i][j] = data[i * cols + j];\n    return reshaped;\n}\n\nvoid minPath(const vector<vector<int>>& grid, int k, vector<int>& result) {\n    int n = grid.size();\n    int x = -1, y = -1;\n    int min = n * n;\n\n    // Find the position of 1 in the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n        }\n    }\n\n    if (x > 0 && grid[x-1][y] < min) min = grid[x-1][y];\n    if (x < n-1 && grid[x+1][y] < min) min = grid[x+1][y];\n    if (y > 0 && grid[x][y-1] < min) min = grid[x][y-1];\n    if (y < n-1 && grid[x][y+1] < min) min = grid[x][y+1];\n\n    result.resize(k);\n    for (int i = 0; i < k; ++i) {\n        result[i] = (i % 2 == 0) ? 1 : min;\n    }\n}\n\nbool issame(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size()) return false;\n \n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i])\n            return false;\n    }\n    return true;\n}\n\nvoid test_minPath() {\n    vector<vector<int>> grid;\n    vector<int> result;\n    int k;\n\n    // Test case 1\n    grid = reshape({1, 2, 3, 4, 5, 6, 7, 8, 9}, 3, 3);\n    k = 3;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1}));\n\n    // Test case 2\n    grid = reshape({5, 9, 3, 4, 1, 6, 7, 8, 2}, 3, 3);\n    k = 1;\n    minPath(grid, k, result);\n    assert(issame(result, {1}));\n\n    // Test case 3\n    grid = reshape({1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}, 4, 4);\n    k = 4;\n    minPath(grid, k, result);\n    assert(issame(result, {1, 2, 1, 2}));\n\n    // Add more test cases as needed\n\n    cout << "All test cases passed!" << endl;\n}\n\nint main() {\n    test_minPath();\n    return 0;\n}\n```\n\n### Explanation:\n1. **Reshape Function**: The `reshape` function is used to convert a 1D array into a 2D vector, mimicking the `reshape` functionality in Fortran.\n\n2. **minPath Function**: This function implements the main logic to find the path in the grid and fills the result vector with alternating `1` and the minimum adjacent number to `1`.\n\n3. **issame Function**: This function checks if two vectors are the same.\n\n4. **Test Cases**: `test_minPath` is the main testing function, which sets up the grids, calls the `minPath` function and uses assertions to validate the result.\n\n5. **Main Function**: The `main` function simply calls the `test_minPath` function to execute the test cases.\n\nThis C++ code should behave similarly to the provided Fortran code, executing the specific logic and test cases correctly.
Here's the translation of the provided Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nvoid tri(int n, std::vector<int>& out);\nbool issame(const std::vector<int>& a, const std::vector<int>& b);\nvoid test_tri(int n, const std::vector<int>& expected);\n\nint main() {\n    test_tri(3, {1, 3, 2, 8});\n    test_tri(4, {1, 3, 2, 8, 3});\n    test_tri(5, {1, 3, 2, 8, 3, 15});\n    test_tri(6, {1, 3, 2, 8, 3, 15, 4});\n    test_tri(7, {1, 3, 2, 8, 3, 15, 4, 24});\n    test_tri(8, {1, 3, 2, 8, 3, 15, 4, 24, 5});\n    test_tri(9, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35});\n    test_tri(20, {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11});\n    test_tri(0, {1});\n    test_tri(1, {1, 3});\n\n    return 0;\n}\n\nvoid test_tri(int n, const std::vector<int>& expected) {\n    std::vector<int> result;\n    tri(n, result);\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed for n = " << n << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n}\n\nvoid tri(int n, std::vector<int>& out) {\n    if (n == 0) {\n        out = {1};\n        return;\n    }\n\n    out.resize(n + 1);\n    out[0] = 1;\n    out[1] = 3;\n\n    for (int i = 2; i <= n; ++i) {\n        if ((i - 1) % 2 == 0) {\n            out[i] = 1 + (i - 1) / 2;\n        } else {\n            out[i] = out[i - 1] + out[i - 2] + 1 + (i / 2);\n        }\n    }\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n\n### Explanation:\n1. **Libraries and Function Declarations**: At the beginning, necessary libraries are included, and function declarations are made.\n2. **`main` Function**: Calls `test_tri` similar to the Fortran `main` program.\n3. **`test_tri` Function**: Calls `tri` and checks the assertion with `issame`. If the assertion fails, it prints an error message and exits.\n4. **`tri` Function**: Implements the logic of creating the sequence, similar to the Fortran `tri` subroutine.\n5. **`issame` Function**: Compares two vectors for equality.\n\n### Points to Notice:\n- **Vector Handling**: Used `std::vector<int>` to handle dynamic arrays in C++.\n- **Indexing**: Adjusted from Fortran's 1-based indexing to C++'s 0-based indexing.\n- **Error handling**: Used `std::cerr` for error messages and `std::exit(EXIT_FAILURE)` for exiting the program on assertion failure.\n- **Initialization and Resize**: Resized vector using `resize` method of `std::vector`.
Certainly! Here is the Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nint digits(int n);\nvoid assert(bool condition);\n\nint main() {\n    // Assertions\n    assert(digits(5) == 5);\n    assert(digits(54) == 5);\n    assert(digits(120) == 1);\n    assert(digits(5014) == 5);\n    assert(digits(98765) == 315);\n    assert(digits(5576543) == 2625);\n    assert(digits(2468) == 0);\n\n    return 0;\n}\n\nint digits(int n) {\n    int prod = 1;\n    bool has = false;\n    std::string s = std::to_string(n);  // Convert integer to string\n\n    for (char c : s) {\n        if ((c - '0') % 2 == 1) {\n            has = true;\n            prod *= (c - '0');\n        }\n    }\n\n    if (!has) {\n        return 0;\n    } else {\n        return prod;\n    }\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n```\n\nThis C++ code performs the same operations as the Fortran code:\n\n1. It defines a `digits` function that computes the product of all odd digits in the given number.\n2. It uses `assert` to check if the returned values from `digits` match the expected values.\n3. If an assertion fails, it prints "Assertion failed" and exits the program with a non-zero status.
Sure, here is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool is_nested(const std::string& str) {\n    int count = 0;\n    int maxcount = 0;\n\n    for (char c : str) {\n        if (c == '[') count++;\n        if (c == ']') count--;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid assert_true(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert_true(is_nested("[[]]") == true);\n    assert_true(is_nested("[]]]]]]][[[[[]") == false);\n    assert_true(is_nested("[][]") == false);\n    assert_true(is_nested("[]") == false);\n    assert_true(is_nested("[[[[]]]]") == true);\n    assert_true(is_nested("[]]]]]]]]]]") == false);\n    assert_true(is_nested("[][][[]]") == true);\n    assert_true(is_nested("[[]") == false);\n    assert_true(is_nested("[]]") == false);\n    assert_true(is_nested("[[]][[") == true);\n    assert_true(is_nested("[[][]]") == true);\n    assert_true(is_nested("") == false);\n    assert_true(is_nested("[[[[[[[[") == false);\n    assert_true(is_nested("]]]]]]]]") == false);\n}\n\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\nIn this translation:\n\n- The `is_nested` logical function in Fortran is translated to a `bool` function in C++.\n- The `assert` subroutine in Fortran is translated to an `assert_true` function in C++.\n- The `run_tests` subroutine in Fortran has been translated into a `run_tests` function in C++.\n- The main body of the Fortran program is translated to the `main` function in C++ which calls `run_tests`.\n\nPlease note that error output is directed to `std::cerr` and the program exits with `std::exit(1)` on assertion failure, which is the equivalent of the Fortran `call exit(1)`.
Translating Fortran code to C++ involves careful conversion, especially for specialized features like dynamic arrays and mathematical functions. Below is a C++ equivalent of the provided Fortran code:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <cstdlib>\n\nint sum_squares(const std::vector<float>& lst) {\n    int sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        sum += std::ceil(lst[i]) * std::ceil(lst[i]);\n    }\n\n    return sum;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nvoid run_tests() {\n    assert_condition(sum_squares({1.0, 2.0, 3.0}) == 14);\n    assert_condition(sum_squares({1.0, 2.0, 3.0}) == 14);  // This duplicate line is intentional\n    assert_condition(sum_squares({1.0, 3.0, 5.0, 7.0}) == 84);\n    assert_condition(sum_squares({1.4, 4.2, 0.0}) == 29);\n    assert_condition(sum_squares({-2.4, 1.0, 1.0}) == 6);\n    assert_condition(sum_squares({100.0, 1.0, 15.0, 2.0}) == 10230);\n    assert_condition(sum_squares({10000.0, 10000.0}) == 200000000);\n    assert_condition(sum_squares({-1.4, 4.6, 6.3}) == 75);\n    assert_condition(sum_squares({-1.4, 17.9, 18.9, 19.9}) == 1086);\n    assert_condition(sum_squares({0.0}) == 0);\n    assert_condition(sum_squares({-1.0}) == 1);\n    assert_condition(sum_squares({-1.0, 1.0, 0.0}) == 2);\n}\n\nint main() {\n    run_tests();\n\n    std::cout << "All tests passed successfully." << std::endl;\n\n    return 0;\n}\n```\n\nHere's a detailed walkthrough of the translation:\n1. **Function `sum_squares`**:\n    - The Fortran function `sum_squares` is translated to a C++ function that takes a `std::vector<float>` as input.\n    - In C++, the `std::ceil` function from the `cmath` library is used to perform the ceiling operation.\n    - A loop iterates over the elements of the vector, calculates their ceiling values, squares them, and accumulates the sum.\n\n2. **Subroutine `assert`**:\n    - The Fortran subroutine `assert` is translated to a C++ function `assert_condition` using the standard library's `assert` and `exit`.\n\n3. **Subroutine `run_tests`**:\n    - The Fortran `run_tests` subroutine is directly translated to a C++ function `run_tests`.\n    - Calls to `assert_condition` test the `sum_squares` function with various inputs.\n    - C++ `assert` is avoided here in favor of manually checking the conditions and printing "Assertion failed" if any test fails, similar to the Fortran version.\n\n4. **Main Program**:\n    - The main program in Fortran becomes the `main` function in C++, which calls `run_tests` and prints a success message if no assertions fail.\n\nThis translation mirrors the Fortran logic while respecting C++ conventions and language features.
Here is the C++ translation of the given Fortran code. This translation uses C++ constructs and standard library functionality to match the behavior of the original Fortran program.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n\nint can_arrange(const std::vector<int>& arr) {\n    int n = arr.size();\n    int max = -1;\n    for (int i = 1; i <= n; ++i) {\n        if (arr[i - 1] <= i - 1) {\n            max = i - 1;\n        }\n    }\n    return max;\n}\n\nint can_arrange_empty() {\n    return -1;\n}\n\nint main() {\n    int result;\n\n    result = can_arrange({1, 2, 4, 3, 5});\n    if (result != 3) {\n        std::cout << "Assertion failed: can_arrange({1,2,4,3,5}) != 3" << std::endl;\n        std::exit(1);\n    }\n\n    result = can_arrange({1, 2, 4, 5});\n    if (result != -1) {\n        std::cout << "Assertion failed: can_arrange({1,2,4,5}) != -1" << std::endl;\n        std::exit(1);\n    }\n\n    result = can_arrange({1, 4, 2, 5, 6, 7, 8, 9, 10});\n    if (result != 2) {\n        std::cout << "Assertion failed: can_arrange({1,4,2,5,6,7,8,9,10}) != 2" << std::endl;\n        std::exit(1);\n    }\n\n    result = can_arrange({4, 8, 5, 7, 3});\n    if (result != 4) {\n        std::cout << "Assertion failed: can_arrange({4,8,5,7,3}) != 4" << std::endl;\n        std::exit(1);\n    }\n\n    // Handle the empty vector case separately\n    result = can_arrange_empty();\n    if (result != -1) {\n        std::cout << "Assertion failed: can_arrange({}) != -1" << std::endl;\n        std::exit(1);\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function `can_arrange`**: This function takes a `std::vector<int>` as input (representing the array) and calculates the maximum index `max` for which the value `arr[i - 1] <= i - 1` holds, similar to the Fortran code. It returns the `max` value.\n\n2. **Function `can_arrange_empty`**: This function simply returns `-1`, similar to the Fortran version.\n\n3. **Main Function**: In the main function, several test cases are used to check the correctness of the `can_arrange` function. If any test case fails, an assertion failed message is printed, and the program exits with a non-zero status. If all tests pass, it prints "All tests passed."\n\n### Things to Note:\n- In C++, array indices start from `0` contrary to Fortran where they often start from `1`.\n- The use of `std::exit(1)` is to mimic the `call exit(1)` functionality from Fortran.\n- Asserting that empty array results are handled correctly using `can_arrange_empty`.\n- `std::vector` is used in C++ to handle dynamic arrays.\n\nThis translation provides the same functionality as the original Fortran code, ensuring the logic and behavior remain consistent.
Here's the translation of the provided Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <algorithm>\n\n// Function to find the largest negative and smallest positive elements in the array\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int maxneg = 0, minpos = 0;\n\n    for (auto num : lst) {\n        if (num < 0 && (maxneg == 0 || num > maxneg)) maxneg = num;\n        if (num > 0 && (minpos == 0 || num < minpos)) minpos = num;\n    }\n\n    return {maxneg, minpos};\n}\n\n// Function to compare two integer arrays\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to assert a condition, exits if condition is false\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\n// Subroutine to run a test case with given input array and expected result\nvoid test_case(const std::vector<int>& input_array, const std::vector<int>& expected) {\n    std::vector<int> test_array(input_array);\n    assert(issame(largest_smallest_integers(test_array), expected));\n}\n\n// Subroutine to run a test case with an empty array and expected result\nvoid test_case_empty(const std::vector<int>& expected) {\n    std::vector<int> test_array;\n    assert(issame(largest_smallest_integers(test_array), expected));\n}\n\n// Subroutine to run all tests\nvoid run_tests() {\n    test_case({2, 4, 1, 3, 5, 7}, {0, 1});\n    test_case({2, 4, 1, 3, 5, 7, 0}, {0, 1});\n    test_case({1, 3, 2, 4, 5, 6, -2}, {-2, 1});\n    test_case({4, 5, 3, 6, 2, 7, -7}, {-7, 2});\n    test_case({7, 3, 8, 4, 9, 2, 5, -9}, {-9, 2});\n    test_case({0}, {0, 0});\n    test_case({-1, -3, -5, -6}, {-1, 0});\n    test_case({-1, -3, -5, -6, 0}, {-1, 0});\n    test_case({-6, -4, -4, -3, 1}, {-3, 1});\n    test_case({-6, -4, -4, -3, -100, 1}, {-3, 1});\n\n    // Special case for empty array\n    test_case_empty({0, 0});\n}\n\n// Main function\nint main() {\n    run_tests();\n    return 0;\n}\n```\n\n### Explanation:\n- **`largest_smallest_integers` Function**:\n  Translates the functionality to find the largest negative and smallest positive numbers in the provided list.\n  \n- **`issame` Function**:\n  Compares if two vectors of integers are the same in length and contents.\n\n- **`assert` Function**:\n  Checks a condition and if false, prints an error message and terminates the program.\n\n- **`test_case` and `test_case_empty` Functions**:\n  Tests the `largest_smallest_integers` function using provided inputs and compares with expected outputs. The assert function is called to ensure the results match expected outputs.\n\n- **`run_tests` Function**:\n  Automated testing with a set of predefined test cases.\n\nThis C++ version should replicate the logic and flow of the provided Fortran code and includes proper error handling using assertions.
Sure, here's the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstdlib>\n\nint64_t special_factorial(int n) {\n    int64_t fact = 1;\n    int64_t bfact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact *= i;\n        bfact *= fact;\n    }\n    return bfact;\n}\n\nint main() {\n    int64_t result;\n\n    // Test cases\n    result = special_factorial(4);\n    if (result != 288) {\n        std::cerr << "special_factorial(4) == 288: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(5);\n    if (result != 34560) {\n        std::cerr << "special_factorial(5) == 34560: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(7);\n    if (result != 125411328000) {\n        std::cerr << "special_factorial(7) == 125411328000: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    result = special_factorial(1);\n    if (result != 1) {\n        std::cerr << "special_factorial(1) == 1: assertion failed" << std::endl;\n        std::exit(1);\n    }\n\n    return 0;\n}\n```\n\nIn this translation:\n\n1. The Fortran `integer(int64)` type is appropriately translated to `int64_t` from the C++ Standard Library `<cstdint>`.\n2. Fortran `implicit none` is assumed and variables are declared explicitly in C++.\n3. The factorial calculation logic remains within the `special_factorial` function.\n4. The Fortran `write` statements are converted to `std::cerr` which is appropriate for error messages in C++.\n5. The `exit` subroutine is replaced by `std::exit` from the C++ Standard Library `<cstdlib>`. \n\nEach test case verifies if the resulting value matches the expected one, printing an assertion failed message and exiting with an error code if it does not match.
Sure! Below is the equivalent C++ code that translates the Fortran program to C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cctype>\n\nbool file_name_check(const std::string& file_name) {\n    int numdigit = 0;\n    int numdot = 0;\n    size_t len = file_name.length();\n\n    if (len < 5) {\n        return false;\n    }\n\n    char w = file_name[0];\n    if (!isalpha(w)) {\n        return false;\n    }\n\n    std::string last = file_name.substr(len - 4);\n    if (last != ".txt" && last != ".exe" && last != ".dll") {\n        return false;\n    }\n\n    for (char c : file_name) {\n        if (isdigit(c)) numdigit++;\n        if (c == '.') numdot++;\n    }\n\n    return numdigit <= 3 && numdot == 1;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        exit(1);\n    }\n}\n\nint main() {\n    assert(file_name_check("example.txt") == true);\n    assert(file_name_check("1example.dll") == false);\n    assert(file_name_check("s1sdf3.asd") == false);\n    assert(file_name_check("K.dll") == true);\n    assert(file_name_check("MY16FILE3.exe") == true);\n    assert(file_name_check("His12FILE94.exe") == false);\n    assert(file_name_check("_Y.txt") == false);\n    assert(file_name_check("?aREYA.exe") == false);\n    assert(file_name_check("/this_is_valid.dll") == false);\n    assert(file_name_check("this_is_valid.wow") == false);\n    assert(file_name_check("this_is_valid.txt") == true);\n    assert(file_name_check("this_is_valid.txtexe") == false);\n    assert(file_name_check("#this2_i4s_5valid.ten") == false);\n    assert(file_name_check("@this1_is6_valid.exe") == false);\n    assert(file_name_check("this_is_12valid.6exe4.txt") == false);\n    assert(file_name_check("all.exe.txt") == false);\n    assert(file_name_check("I563_No.exe") == true);\n    assert(file_name_check("Is3youfault.txt") == true);\n    assert(file_name_check("no_one#knows.dll") == true);\n    assert(file_name_check("1I563_Yes3.exe") == false);\n    assert(file_name_check("I563_Yes3.txtt") == false);\n    assert(file_name_check("final..txt") == false);\n    assert(file_name_check("final132") == false);\n    assert(file_name_check("_f4indsartal132.") == false);\n    assert(file_name_check(".txt") == false);\n    assert(file_name_check("s.") == false);\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}\n```\n\nThis C++ program consists of a similar `file_name_check` function and a main function to call the test cases using assertions, similar to those in the Fortran code. Note that some of the Fortran-specific functionalities, such as string handling and character code checking, have been translated using standard C++ functionalities.
Here's the equivalent C++ code for the given Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool simplify(const std::string &x, const std::string &n) {\n    auto pos1 = x.find('/');\n    int a = std::stoi(x.substr(0, pos1));\n    int b = std::stoi(x.substr(pos1 + 1));\n\n    auto pos2 = n.find('/');\n    int c = std::stoi(n.substr(0, pos2));\n    int d = std::stoi(n.substr(pos2 + 1));\n\n    return (a * c % b * d == 0);\n}\n\nvoid assert_simplify(bool result, const std::string &message) {\n    if (!result) {\n        std::cerr << "Assertion failed: " << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assert_simplify(simplify("1/5", "5/1"), "simplify('1/5', '5/1') == true");\n    assert_simplify(!simplify("1/6", "2/1"), "simplify('1/6', '2/1') == false");\n    assert_simplify(simplify("5/1", "3/1"), "simplify('5/1', '3/1') == true");\n    assert_simplify(!simplify("7/10", "10/2"), "simplify('7/10', '10/2') == false");\n    assert_simplify(simplify("2/10", "50/10"), "simplify('2/10', '50/10') == true");\n    assert_simplify(simplify("7/2", "4/2"), "simplify('7/2', '4/2') == true");\n    assert_simplify(simplify("11/6", "6/1"), "simplify('11/6', '6/1') == true");\n    assert_simplify(!simplify("2/3", "5/2"), "simplify('2/3', '5/2') == false");\n    assert_simplify(!simplify("5/2", "3/5"), "simplify('5/2', '3/5') == false");\n    assert_simplify(simplify("2/4", "8/4"), "simplify('2/4', '8/4') == true");\n    assert_simplify(simplify("2/4", "4/2"), "simplify('2/4', '4/2') == true");\n    assert_simplify(simplify("1/5", "5/1"), "simplify('1/5', '5/1') == true");\n    assert_simplify(!simplify("1/5", "1/5"), "simplify('1/5', '1/5') == false");\n\n    std::cout << "All assertions passed." << std::endl;\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Function Definition**:\n   - I defined a function `simplify` that takes two `std::string` arguments and returns a `bool`.\n   - Inside the function, I extract the numerator and denominator from the input strings using `std::stoi` and `substr`.\n   - The function returns `true` if the multiplication of the simplified fractions maintains the modular equality condition given in Fortran.\n\n2. **Assertions**:\n   - The `assert_simplify` function checks the result of `simplify` and prints an error message and exits if the assertion fails.\n   \n3. **Main Function**:\n   - The main function performs several assertions to verify the `simplify` function, similar to the original Fortran program.\n   - Each assertion checks the expected result and prints an error and exits if the condition is not met.\n   - If all assertions pass, it prints "All assertions passed."\n\nMake sure you include the necessary headers and use appropriate namespaces (`std` in this case) in a real C++ program.
Here's a C++ translation of the provided Fortran code. This translation retains the functionality and logic while incorporating C++ features and syntax.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cassert>\n\n// Helper function to calculate the digit sum of a number\nint digit_sum(int num) {\n    int sum = 0;\n    std::string s = std::to_string(std::abs(num));\n    for (char c : s) {\n        sum += c - '0';\n    }\n    return num < 0 ? sum - 2 * (s[0] - '0') : sum;\n}\n\n// Function to sort numbers according to the digit sum logic\nstd::vector<int> order_by_points(const std::vector<int>& nums) {\n    if (nums.empty()) {\n        return {};\n    }\n\n    // Copy input vector to allow sorting\n    std::vector<int> sorted_nums = nums;\n    std::sort(sorted_nums.begin(), sorted_nums.end(),\n        [](int a, int b) {\n            int sum_a = digit_sum(a);\n            int sum_b = digit_sum(b);\n            if (sum_a == sum_b) {\n                return a < b;\n            }\n            return sum_a < sum_b;\n        });\n  \n    return sorted_nums;\n}\n\n// Function to check if two vectors are equal\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    return a == b;\n}\n\n// Function to assert a condition\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> nums;\n    std::vector<int> result;\n\n    // Test cases\n\n    nums = {1, 11, -1, -11, -12};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-1, -11, 1, -12, 11}));\n\n    nums = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457}));\n\n    nums = {};\n    result = order_by_points(nums);\n    assert_condition(issame(result, nums));\n\n    nums = {1, -11, -32, 43, 54, -98, 2, -3};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-3, -32, -98, -11, 1, 2, 43, 54}));\n\n    nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9}));\n\n    nums = {0, 6, 6, -76, -21, 23, 4};\n    result = order_by_points(nums);\n    assert_condition(issame(result, {-76, -21, 0, 4, 23, 6, 6}));\n\n    return 0;\n}\n```\n\n### Explanation\n\n- **digit_sum**: This function calculates the "digit sum" of a given number using the logic provided in the Fortran code.\n- **order_by_points**: Sorts the input numbers based on their "digit sums" using `std::sort` with a custom comparison lambda function.\n- **issame**: Checks if two vectors are identical.\n- **assert_condition**: Writes an error message and exits if the condition is false.\n- **main**: Contains the test cases from the original Fortran code, now adapted to use the C++ functions.
Certainly! Below is the translation of the provided Fortran code to C++.\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nint specialFilter(const std::vector<int>& nums) {\n    int num = 0;\n    for (int n : nums) {\n        if (n > 10) {\n            std::stringstream ss;\n            ss << n;\n            std::string w = ss.str();\n\n            if ((w.front() - '0') % 2 == 1 && (w.back() - '0') % 2 == 1) {\n                num++;\n            }\n        }\n    }\n    return num;\n}\n\nint specialFilterEmpty() {\n    return 0;\n}\n\nint main() {\n    int result;\n\n    // Test cases\n    result = specialFilter({5, -2, 1, -5});\n    if (result != 0) {\n        std::cerr << "Test case 1 failed\n";\n        return 1;\n    }\n\n    result = specialFilter({15, -73, 14, -15});\n    if (result != 1) {\n        std::cerr << "Test case 2 failed\n";\n        return 1;\n    }\n\n    result = specialFilter({33, -2, -3, 45, 21, 109});\n    if (result != 2) {\n        std::cerr << "Test case 3 failed\n";\n        return 1;\n    }\n\n    result = specialFilter({43, -12, 93, 125, 121, 109});\n    if (result != 4) {\n        std::cerr << "Test case 4 failed\n";\n        return 1;\n    }\n\n    result = specialFilter({71, -2, -33, 75, 21, 19});\n    if (result != 3) {\n        std::cerr << "Test case 5 failed\n";\n        return 1;\n    }\n\n    result = specialFilter({1});\n    if (result != 0) {\n        std::cerr << "Test case 6 failed\n";\n        return 1;\n    }\n\n    // Handle empty array case separately\n    result = specialFilterEmpty();\n    if (result != 0) {\n        std::cerr << "Test case 7 failed\n";\n        return 1;\n    }\n\n    std::cout << "All test cases passed\n";\n    return 0;\n}\n```\n\n### Explanation:\n1. **Function `specialFilter`**:\n   - It takes a vector of integers as input.\n   - It iterates over each number in the vector.\n   - If the number is greater than 10, it converts the number to a string.\n   - It then checks if both the first and last characters of the string representation are odd.\n   - If both are odd, it increments the count.\n\n2. **Function `specialFilterEmpty`**:\n   - Simply returns 0, mimicking the empty array special case in the Fortran code.\n\n3. **Main Program**:\n   - It runs a series of test cases to verify the functionality of `specialFilter`. If any test fails, it prints an error message and exits with a non-zero status.\n   - Provided tests match exactly those in the original Fortran program.\n\n### Notes:\n- The C++ std::vector is used to hold the arrays passed into `specialFilter`.\n- The std::stringstream and std::string objects are used for converting integers to their string equivalents.\n- The `main` function performs the test checks and output similar to the Fortran program with the console output and checks.
Below is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <stdexcept>\n\n// Function to compute matrix triples\nint get_matrix_triples(int n) {\n    // Declaring variables\n    int i, j, times;\n    std::vector<int> a(n);\n    std::vector<std::vector<int>> sum(n + 1, std::vector<int>(3, 0));\n    std::vector<std::vector<int>> sum2(n + 1, std::vector<int>(3, 0));\n\n    // Fill array 'a' and compute initial sums\n    for (i = 1; i <= n; ++i) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        sum[i] = sum[i - 1];\n        sum[i][a[i - 1]] += 1;\n    }\n\n    // Compute sums for times = 1 and 2\n    for (times = 1; times <= 2; ++times) {\n        for (i = 1; i <= n; ++i) {\n            sum2[i] = sum2[i - 1];\n            for (j = 0; j <= 2; ++j) {\n                sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n            }\n        }\n        sum = sum2;\n        std::fill(sum2.begin(), sum2.end(), std::vector<int>(3, 0));\n    }\n\n    return sum[n][0];\n}\n\n// Main function for testing\nint main() {\n    try {\n        // Test cases\n        int result;\n\n        result = get_matrix_triples(5);\n        if (result != 1) {\n            throw std::runtime_error("Assertion failed: get_matrix_triples(5) == 1");\n        }\n\n        result = get_matrix_triples(6);\n        if (result != 4) {\n            throw std::runtime_error("Assertion failed: get_matrix_triples(6) == 4");\n        }\n\n        result = get_matrix_triples(10);\n        if (result != 36) {\n            throw std::runtime_error("Assertion failed: get_matrix_triples(10) == 36");\n        }\n\n        result = get_matrix_triples(100);\n        if (result != 53361) {\n            throw std::runtime_error("Assertion failed: get_matrix_triples(100) == 53361");\n        }\n\n        std::cout << "All test cases passed successfully." << std::endl;\n    } catch (const std::exception &e) {\n        std::cerr << e.what() << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Initialization and Arrays**:\n   - `std::vector<int>` is used for the array `a` and 2D vectors `sum` and `sum2`.\n   - These vectors are initialized to the sizes and values corresponding to the Fortran version.\n\n2. **Filling the Array and Initial Sums**:\n   - The loop initializes the `a` array and computes initial sums, similar to the original Fortran code but using 1-based indexing where necessary.\n\n3. **Computing Sums**:\n   - The double loop handles the computation for `times = 1` and `times = 2`, similar to the Fortran version. `std::fill` is used to reset the `sum2` vector.\n\n4. **Main Function and Test Cases**:\n   - Test cases check the outputs, with error messages thrown using `std::runtime_error` if the results do not match expected values.\n\nFeel free to copy this C++ code and run it in your preferred C++ development environment.
Sure! Below is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nint x_or_y(int n, int x, int y) {\n    bool isp = true;\n    if (n < 2) isp = false;\n    for (int i = 2; i <= static_cast<int>(std::sqrt(n)); ++i) {\n        if (n % i == 0) {\n            isp = false;\n            break;\n        }\n    }\n\n    if (isp) {\n        return x;\n    } else {\n        return y;\n    }\n}\n\nvoid assertEqual(int result, int expected, const std::string& message) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: " << message << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    assertEqual(x_or_y(7, 34, 12), 34, "x_or_y(7, 34, 12) == 34");\n    assertEqual(x_or_y(15, 8, 5), 5, "x_or_y(15, 8, 5) == 5");\n    assertEqual(x_or_y(3, 33, 5212), 33, "x_or_y(3, 33, 5212) == 33");\n    assertEqual(x_or_y(1259, 3, 52), 3, "x_or_y(1259, 3, 52) == 3");\n    assertEqual(x_or_y(7919, -1, 12), -1, "x_or_y(7919, -1, 12) == -1");\n    assertEqual(x_or_y(3609, 1245, 583), 583, "x_or_y(3609, 1245, 583) == 583");\n    assertEqual(x_or_y(91, 56, 129), 129, "x_or_y(91, 56, 129) == 129");\n    assertEqual(x_or_y(6, 34, 1234), 1234, "x_or_y(6, 34, 1234) == 1234");\n    assertEqual(x_or_y(1, 2, 0), 0, "x_or_y(1, 2, 0) == 0");\n    assertEqual(x_or_y(2, 2, 0), 2, "x_or_y(2, 2, 0) == 2");\n\n    std::cout << "All assertions passed." << std::endl;\n\n    return 0;\n}\n```\n\nExplanation:\n\n1. The `x_or_y` function checks if the number `n` is prime. If it is, it returns `x`; otherwise, it returns `y`.\n2. The `assertEqual` function is a helper to perform assertions. If the result is not as expected, it prints an error message and exits the program.\n3. The `main` function runs the assertions, which mimic the assertions from the Fortran code.\n4. The program uses standard C++ libraries such as `<iostream>`, `<cmath>`, and `<cstdlib>` for input/output operations, mathematical functions, and program exit functionality, respectively.
Certainly! Here is the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cassert>\n#include <cstdlib>\n\n// Function prototypes\nint double_the_difference(const std::vector<double>& lst);\nvoid assert_condition(bool condition);\n\nint main() {\n    // Test cases\n    assert_condition(double_the_difference({0.0}) == 0);\n    assert_condition(double_the_difference({5.0, 4.0}) == 25);\n    assert_condition(double_the_difference({0.1, 0.2, 0.3}) == 0);\n    assert_condition(double_the_difference({-10.0, -20.0, -30.0}) == 0);\n    assert_condition(double_the_difference({-1.0, -2.0, 8.0}) == 0);\n    assert_condition(double_the_difference({0.2, 3.0, 5.0}) == 34);\n\n    // Initialize variables\n    int64_t odd_sum = 0;\n    std::vector<double> lst(100, 0.0);\n\n    // Fill the array and calculate odd_sum\n    for (int i = -99; i <= 99; i += 2) {\n        lst[(i + 101) / 2] = static_cast<double>(i);\n        if (i > 0 && i % 2 == 1) {\n            odd_sum += i * i;\n        }\n    }\n\n    // Check the final assertion\n    int64_t result = double_the_difference(lst);\n    assert_condition(result == odd_sum);\n\n    return 0;\n}\n\nint double_the_difference(const std::vector<double>& lst) {\n    int64_t sum = 0;\n\n    for (const auto& value : lst) {\n        double rounded_value = std::round(value);\n        if (std::abs(value - rounded_value) < 1e-4) {\n            if (value > 0 && static_cast<int>(rounded_value) % 2 == 1) {\n                sum += static_cast<int64_t>(rounded_value) * static_cast<int64_t>(rounded_value);\n            }\n        }\n    }\n\n    return sum;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n```\n\n### Explanation:\n1. **Main Function**:\n   - We've defined the main function to include test cases using `assert_condition` to validate the `double_the_difference` function.\n   - Initialized `odd_sum` and `lst` similar to the Fortran code.\n   - Populated the `lst` vector and calculated `odd_sum` for positive odd numbers.\n\n2. **Function `double_the_difference`**:\n   - Takes a constant reference to a vector of doubles.\n   - Iterates through the vector, checking if the value is close to its nearest integer.\n   - If it meets the criteria (positive, odd integer), it calculates the square and adds it to the sum.\n\n3. **Assertion Function**:\n   - Checks a condition and prints a failure message if the condition is not met, terminating the application using `std::exit(1)` to simulate Fortran's `call exit(1)`.\n\n### Notes:\n- C++ does not support automatic bounds checking as Fortran does with arrays. Ensure that the vector indexing is correct.\n- The assertion logic has been mimicked using the `assert_condition` function for cleaner assert reporting.\n- Ensure you compile this program with a C++14 or later standard to use the `int64_t` type without issues.
Sure, here's the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nbool cycpattern_check(const std::string& a, const std::string& b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    \n    for (int i = 0; i < len_b; ++i) {\n        std::string rotate = b.substr(i, len_b - i) + b.substr(0, i);\n        // Debugging print statement\n        // std::cout << "Checking rotation: " << rotate << std::endl;\n        if (a.find(rotate) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    if (cycpattern_check("xyzw", "xyw")) {\n        std::cerr << "Assertion failed: cycpattern_check('xyzw', 'xyw') == false" << std::endl;\n        return 1;\n    }\n\n    if (!cycpattern_check("yello", "ell")) {\n        std::cerr << "Assertion failed: cycpattern_check('yello', 'ell') == true" << std::endl;\n        return 1;\n    }\n\n    if (cycpattern_check("whattup", "ptut")) {\n        std::cerr << "Assertion failed: cycpattern_check('whattup', 'ptut') == false" << std::endl;\n        return 1;\n    }\n\n    if (!cycpattern_check("efef", "fee")) {\n        std::cerr << "Assertion failed: cycpattern_check('efef', 'fee') == true" << std::endl;\n        return 1;\n    }\n\n    if (cycpattern_check("abab", "aabb")) {\n        std::cerr << "Assertion failed: cycpattern_check('abab', 'aabb') == false" << std::endl;\n        return 1;\n    }\n\n    if (!cycpattern_check("winemtt", "tinem")) {\n        std::cerr << "Assertion failed: cycpattern_check('winemtt', 'tinem') == true" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}\n```\n\nIn this C++ translation:\n- I've replaced the Fortran `logical` with the C++ `bool`.\n- I've replaced Fortran string operations with their C++ `std::string` equivalents.\n- The `write` statement for debugging and assertions in Fortran is replaced with `std::cout` and `std::cerr` for print statements.\n- The `call exit(1)` is replaced with `return 1` to exit the program with an error code.\n- The substring operation and concatenation were replaced with `substr` and `+` operations in C++. \n\nThis code should perform the same checks and assertions as your Fortran program.
Sure, here is the equivalent C++ code:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cassert>\n#include <cmath>\n#include <vector>\n\nstd::vector<int> even_odd_count(int num) {\n    std::vector<int> counts(2, 0); // [even_count, odd_count]\n    std::string numStr = std::to_string(std::abs(num));\n    \n    for (char ch : numStr) {\n        int digit = ch - '0';\n        if (digit % 2 == 0) {\n            counts[0]++;\n        } else {\n            counts[1]++;\n        }\n    }\n    \n    return counts;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    \n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) return false;\n    }\n    \n    return true;\n}\n\nvoid assert_condition(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result(2);\n    std::vector<int> expected(2);\n\n    // Test cases\n    result = even_odd_count(7);\n    expected = {0, 1};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(-78);\n    expected = {1, 1};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(3452);\n    expected = {2, 2};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(346211);\n    expected = {3, 3};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(-345821);\n    expected = {3, 3};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(-2);\n    expected = {1, 0};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(-45347);\n    expected = {2, 3};\n    assert_condition(issame(result, expected));\n\n    result = even_odd_count(0);\n    expected = {1, 0};\n    assert_condition(issame(result, expected));\n\n    return 0;\n}\n```\n\nExplanation of the translation:\n- Fortran arrays and dynamic memory management are translated to `std::vector<int>` in C++.\n- The write statement for converting an integer to a string is replaced with `std::to_string`.\n- The `ichar` function is replaced by direct character manipulation (subtracting '0' from a character to get the integer value).\n- Special functions like `issame` and `assert` are directly implemented as C++ functions.\n- The loop structure and logic within functions remain almost the same but adapted syntax to C++. \n\nDo note that the error handling with `assert` function C++ can typically use `assert` from the C standard library, but here is retained as a custom function to keep the structure closer to the Fortran code.
Here's the equivalent C++ code for the given Fortran program.\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n\nstd::string int_to_roman(int number);\nvoid assert(bool condition);\n\nint main() {\n    // Test cases\n    assert(int_to_roman(19) == "xix");\n    assert(int_to_roman(152) == "clii");\n    assert(int_to_roman(251) == "ccli");\n    assert(int_to_roman(426) == "cdxxvi");\n    assert(int_to_roman(500) == "d");\n    assert(int_to_roman(1) == "i");\n    assert(int_to_roman(4) == "iv");\n    assert(int_to_roman(43) == "xliii");\n    assert(int_to_roman(90) == "xc");\n    assert(int_to_roman(94) == "xciv");\n    assert(int_to_roman(532) == "dxxxii");\n    assert(int_to_roman(900) == "cm");\n    assert(int_to_roman(994) == "cmxciv");\n    assert(int_to_roman(1000) == "m");\n\n    return 0;\n}\n\nstd::string int_to_roman(int number) {\n    struct RomanMapping {\n        int value;\n        std::string symbol;\n    };\n\n    // Roman numerals ordered from largest to smallest\n    RomanMapping mappings[] = {\n        {1000, "m"}, {900, "cm"}, {500, "d"}, {400, "cd"},\n        {100, "c"}, {90, "xc"}, {50, "l"}, {40, "xl"},\n        {10, "x"}, {9, "ix"}, {5, "v"}, {4, "iv"}, {1, "i"}\n    };\n\n    std::string result;\n    for (const auto& mapping : mappings) {\n        while (number >= mapping.value) {\n            result += mapping.symbol;\n            number -= mapping.value;\n        }\n    }\n\n    return result;\n}\n\nvoid assert(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n}\n```\n\nThis C++ program consists of:\n\n1. A `main` function with test cases similar to those in the Fortran program.\n2. A `int_to_roman` function that translates the given integer into a Roman numeral string.\n3. An `assert` function that checks conditions and exits the program with an error message if a condition fails.\n\nMake sure to compile and run the program with a C++ compiler (e.g., `g++` or `clang++`) to see the results.
Here's the Fortran code translated to C++:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n\nusing namespace std;\n\n// Function declaration\nbool right_angle_triangle(float a, float b, float c) {\n    float epsilon = 1.0e-4;\n\n    if (abs(a * a + b * b - c * c) < epsilon || abs(a * a + c * c - b * b) < epsilon || abs(b * b + c * c - a * a) < epsilon) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    // Assertions\n    if (!right_angle_triangle(3.0, 4.0, 5.0)) {\n        cout << "Assertion failed: right_angle_triangle(3, 4, 5) == true" << endl;\n        exit(1);\n    }\n\n    if (right_angle_triangle(1.0, 2.0, 3.0)) {\n        cout << "Assertion failed: right_angle_triangle(1, 2, 3) == false" << endl;\n        exit(1);\n    }\n\n    if (!right_angle_triangle(10.0, 6.0, 8.0)) {\n        cout << "Assertion failed: right_angle_triangle(10, 6, 8) == true" << endl;\n        exit(1);\n    }\n\n    if (right_angle_triangle(2.0, 2.0, 2.0)) {\n        cout << "Assertion failed: right_angle_triangle(2, 2, 2) == false" << endl;\n        exit(1);\n    }\n\n    if (!right_angle_triangle(7.0, 24.0, 25.0)) {\n        cout << "Assertion failed: right_angle_triangle(7, 24, 25) == true" << endl;\n        exit(1);\n    }\n\n    if (right_angle_triangle(10.0, 5.0, 7.0)) {\n        cout << "Assertion failed: right_angle_triangle(10, 5, 7) == false" << endl;\n        exit(1);\n    }\n\n    if (!right_angle_triangle(5.0, 12.0, 13.0)) {\n        cout << "Assertion failed: right_angle_triangle(5, 12, 13) == true" << endl;\n        exit(1);\n    }\n\n    if (!right_angle_triangle(15.0, 8.0, 17.0)) {\n        cout << "Assertion failed: right_angle_triangle(15, 8, 17) == true" << endl;\n        exit(1);\n    }\n\n    if (!right_angle_triangle(48.0, 55.0, 73.0)) {\n        cout << "Assertion failed: right_angle_triangle(48, 55, 73) == true" << endl;\n        exit(1);\n    }\n\n    if (right_angle_triangle(1.0, 1.0, 1.0)) {\n        cout << "Assertion failed: right_angle_triangle(1, 1, 1) == false" << endl;\n        exit(1);\n    }\n\n    if (right_angle_triangle(2.0, 2.0, 10.0)) {\n        cout << "Assertion failed: right_angle_triangle(2, 2, 10) == false" << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n```\n\nIn this C++ code:\n- The `right_angle_triangle` function is defined with `float` parameters, similar to the Fortran `real` type. It checks if the given sides form a right-angle triangle within a small epsilon tolerance.\n- The `main` function contains the same set of assertions using `if` conditions, where `std::cout` is used to print the error messages to the console.\n- Instead of `call exit(1)`, `exit(1)` from `<cstdlib>` is used to terminate the program.
Here's the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n\nstd::string find_max(const std::vector<std::string>& words) {\n    std::string max_word = "";\n    int max_unique_chars = 0;\n\n    for (const auto& word : words) {\n        std::string unique_chars = "";\n        for (const char& ch : word) {\n            if (unique_chars.find(ch) == std::string::npos) {\n                unique_chars += ch;\n            }\n        }\n\n        int unique_length = unique_chars.length();\n        if (unique_length > max_unique_chars || \n            (unique_length == max_unique_chars && word < max_word)) {\n            max_word = word;\n            max_unique_chars = unique_length;\n        }\n    }\n\n    return max_word;\n}\n\nvoid assert_equal(const std::string& result, const std::string& expected) {\n    if (result != expected) {\n        std::cerr << "Assertion failed: expected '" << expected << "', got '" << result << "'" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    // Test cases\n    {\n        std::vector<std::string> words = {"name   ", "of     ", "string "};\n        assert_equal(find_max(words), "string");\n    }\n\n    {\n        std::vector<std::string> words = {"name   ", "enam   ", "game   "};\n        assert_equal(find_max(words), "enam   ");\n    }\n\n    {\n        std::vector<std::string> words = {"aaaaaaa", "bb     ", "cc     "};\n        assert_equal(find_max(words), "aaaaaaa");\n    }\n\n    {\n        std::vector<std::string> words = {"abc    ", "cba    "};\n        assert_equal(find_max(words), "abc    ");\n    }\n\n    {\n        std::vector<std::string> words = {"play    ", "this    ", "game    ", "of      ", "footbott"};\n        assert_equal(find_max(words), "footbott");\n    }\n\n    {\n        std::vector<std::string> words = {"we      ", "are     ", "gonna   ", "rock    "};\n        assert_equal(find_max(words), "gonna   ");\n    }\n\n    {\n        std::vector<std::string> words = {"we      ", "are     ", "a       ", "mad     ", "nation  "};\n        assert_equal(find_max(words), "nation  ");\n    }\n\n    {\n        std::vector<std::string> words = {"this    ", "is      ", "a       ", "prrk    "};\n        assert_equal(find_max(words), "this    ");\n    }\n\n    {\n        std::vector<std::string> words = {"b       "};\n        assert_equal(find_max(words), "b       ");\n    }\n\n    {\n        std::vector<std::string> words = {"play    ", "play    ", "play    "};\n        assert_equal(find_max(words), "play    ");\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n```\n\nExplanation:\n1. The function `find_max` takes a `std::vector<std::string>` and returns the string with the most unique characters. If there is a tie, it returns the lexicographically smaller string.\n2. The `assert_equal` function helps to verify whether the result meets the expected value, printing an error message and exiting if it fails.\n3. The main function runs several test cases similar to the original Fortran code to ensure correctness. Adjustments were made to store and compare the string values properly, handling spaces and ensuring that comparisons are accurate.\n\n
Below is the translated Fortran code into C++:\n\n```cpp\n#include <iostream>\n#include <array>\n#include <cstdlib>\n\n// Function prototypes\nstd::array<int, 2> eat(int number, int need, int remaining);\nbool issame(const std::array<int, 2>& a, const std::array<int, 2>& b);\n\nint main() {\n    std::array<int, 2> result;\n    std::array<int, 2> expected;\n\n    // Test cases\n    result = eat(5, 6, 10);\n    expected = {11, 4};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(5, 6, 10) == {11, 4}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 8, 9);\n    expected = {12, 1};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 8, 9) == {12, 1}" << std::endl;\n        return 1;\n    }\n\n    result = eat(1, 10, 10);\n    expected = {11, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(1, 10, 10) == {11, 0}" << std::endl;\n        return 1;\n    }\n\n    result = eat(2, 11, 5);\n    expected = {7, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(2, 11, 5) == {7, 0}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 5, 7);\n    expected = {9, 2};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 7) == {9, 2}" << std::endl;\n        return 1;\n    }\n\n    result = eat(4, 5, 1);\n    expected = {5, 0};\n    if (!issame(result, expected)) {\n        std::cerr << "Assertion failed: eat(4, 5, 1) == {5, 0}" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n    return 0;\n}\n\nstd::array<int, 2> eat(int number, int need, int remaining) {\n    std::array<int, 2> res;\n    if (need > remaining) {\n        res = {number + remaining, 0};\n    } else {\n        res = {number + need, remaining - need};\n    }\n    return res;\n}\n\nbool issame(const std::array<int, 2>& a, const std::array<int, 2>& b) {\n    for (int i = 0; i < 2; ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n### Explanation:\n1. **Fortran to C++ Translations:**\n   - Fortran arrays are translated to `std::array<int, 2>` in C++.\n   - `integer` type in Fortran is translated to `int` in C++.\n   - The `write(*,*)` statement in Fortran for output was translated to `std::cout` and `std::cerr` for logging in C++.\n   - The Fortran subroutine `exit(1)` is replaced with `return 1` to exit the program.\n\n2. **Functions:**\n   - Fortran `function eat` is translated to `std::array<int, 2> eat` in C++.\n   - Fortran `function issame` is translated to `bool issame` in C++ that compares C++ arrays element-wise.\n\n3. **Test Cases:**\n   - Sequential test cases are run, and assertions are checked using `if` statements.\n   - If a test case fails, an error message is logged to `std::cerr` and the program exits with a return code of `1`.\n\n4. **Array Initialization:**\n   - Arrays are initialized in C++ using curly braces `{}`.\n\nWith these conversions, the functionality and the logic of the original Fortran code should be preserved in the C++ version.
Sure! Here's the equivalent C++ code for the provided Fortran program:\n\n```cpp\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cctype>\n\n// Function to reverse a string\nstd::string reverse_string(const std::string& s) {\n    return std::string(s.rbegin(), s.rend());\n}\n\n// Function to transform the string according to the given logic\nstd::string solve(const std::string& s) {\n    std::string out;\n    int nletter = 0;\n\n    for (char c : s) {\n        if (std::isupper(c)) {\n            out += std::tolower(c);\n        } else if (std::islower(c)) {\n            out += std::toupper(c);\n        } else {\n            ++nletter;\n            out += c;\n        }\n    }\n\n    if (nletter == s.length()) {\n        out = reverse_string(out);\n    }\n\n    return out;\n}\n\nint main() {\n    std::string s, result;\n\n    // Test cases\n    s = "AsDf";\n    result = solve(s);\n    if (result != "aSdF") {\n        std::cerr << "Assertion failed: solve('AsDf') == 'aSdF'" << std::endl;\n        return 1;\n    }\n\n    s = "1234";\n    result = solve(s);\n    if (result != "4321") {\n        std::cerr << "Assertion failed: solve('1234') == '4321'" << std::endl;\n        return 1;\n    }\n\n    s = "ab";\n    result = solve(s);\n    if (result != "AB") {\n        std::cerr << "Assertion failed: solve('ab') == 'AB'" << std::endl;\n        return 1;\n    }\n\n    s = "#a@C";\n    result = solve(s);\n    if (result != "#A@c") {\n        std::cerr << "Assertion failed: solve('#a@C') == '#A@c'" << std::endl;\n        return 1;\n    }\n\n    s = "#AsdfW^45";\n    result = solve(s);\n    if (result != "#aSDFw^45") {\n        std::cerr << "Assertion failed: solve('#AsdfW^45') == '#aSDFw^45'" << std::endl;\n        return 1;\n    }\n\n    s = "#6@2";\n    result = solve(s);\n    if (result != "2@6#") {\n        std::cerr << "Assertion failed: solve('#6@2') == '2@6#'" << std::endl;\n        return 1;\n    }\n\n    s = "#$a^D";\n    result = solve(s);\n    if (result != "#$A^d") {\n        std::cerr << "Assertion failed: solve('#$a^D') == '#$A^d'" << std::endl;\n        return 1;\n    }\n\n    s = "#ccc";\n    result = solve(s);\n    if (result != "#CCC") {\n        std::cerr << "Assertion failed: solve('#ccc') == '#CCC'" << std::endl;\n        return 1;\n    }\n\n    std::cout << "All tests passed." << std::endl;\n\n    return 0;\n}\n```\n\nThis C++ code replicates the functionality of the original Fortran code, including the logic for string transformation and assertion-based testing.
Here is the translated Fortran code to C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nstd::vector<int> generate_integers(int a, int b) {\n    int temp_a = a;\n    int temp_b = b;\n\n    if (temp_b < temp_a) {\n        std::swap(temp_a, temp_b);\n    }\n\n    std::vector<int> temp;\n\n    for (int i = temp_a; i <= temp_b; ++i) {\n        if (i < 10 && i % 2 == 0) {\n            temp.push_back(i);\n        }\n    }\n\n    return temp;\n}\n\nbool issame(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvoid assert_func(bool condition) {\n    if (!condition) {\n        std::cerr << "Assertion failed" << std::endl;\n        std::exit(1);\n    }\n}\n\nint main() {\n    std::vector<int> result;\n    std::vector<int> empty_array;\n\n    result = generate_integers(2, 10);\n    assert_func(issame(result, {2, 4, 6, 8}));\n\n    result = generate_integers(10, 2);\n    assert_func(issame(result, {2, 4, 6, 8}));\n\n    result = generate_integers(132, 2);\n    assert_func(issame(result, {2, 4, 6, 8}));\n\n    result = generate_integers(17, 89);\n    assert_func(issame(result, empty_array));  // Use the zero-sized array for comparison\n\n    return 0;\n}\n```\n\n### Explanation:\n1. **Data Structures and Types**:\n    - For vectors, we use the `std::vector<int>` type from the C++ Standard Library.\n    - `generate_integers` returns a vector of integers.\n\n2. **Function Definitions**:\n    - `generate_integers` constructs a vector of even integers between `a` and `b` (inclusive) if they are less than 10.\n    - `issame` checks if two vectors have the same elements.\n    - `assert_func` works similarly to the Fortran `assert` subroutine but uses C++'s `assert` and prints a message if the condition fails.\n\n3. **Main Program**:\n    - The main program initializes the vectors and performs the same comparisons and assertions as in the Fortran code.\n\nAll control structures (`if`, `do`, etc.) are mirrored with the equivalent C++ constructs like `if` and `for`. Note that in C++, arrays start at index 0, and `std::vector` is used here instead of dynamically allocated arrays in Fortran.
